#GLOBALS
LINUX_HOST1="10.24.12.84"
LINUX_HOST2="10.24.12.86"
CC_HOST="badaniya-vm"
BUILD_HOST="$CC_HOST"
FWDL_HOST="$LINUX_HOST2"
SS_PATH="$HOME/ss_team"
DOMAIN_NAME="extremenetworks.com"
BASE_SRC="$HOME/workspace/slxos"
MASTER_GODCAPP_SRC="$HOME/workspace/badaniya/master/GoDCApp"

CLEARTOOL=/usr/atria/bin/cleartool

NUM_CPU_CORES=`cat /proc/cpuinfo | grep processor | wc -l`

SWITCH_TERMINAL_GEOMETRY="89x25"
CHASSIS_TERMINAL_GEOMETRY="180x25"
FULL_TERMINAL_GEOMETRY="180x56"

PROMPT_COMMAND='pwd > "$HOME/.cwd"'

# open new terminal in same dir
if [[ -f "$HOME/.cwd" ]]; then 
    cd "$(<$HOME/.cwd)"
fi

host_ip()
{
    hostname -I | cut -d ' ' -f 1
}

get_pathenv()
{
    local SEARCH_PATH="$1"
    local PATH_ENV="$2"

    if [[ -n "$PATH_ENV" ]]; then
        for pathenv in `echo ${PATH_ENV//:/$'\n'}`; do
            if [[ $SEARCH_PATH =~ $pathenv ]]; then
                local count=$(ls -1 ${pathenv}/\*.go 2>/dev/null | wc -l)

                if [[ ${count} -ne 0 ]]; then 
                    echo $pathenv
                fi
            fi
        done
    fi
}

set_ctag_cscope_path()
{
    if [ -e "$CLEARTOOL" ]; then
        CURRENT_VIEW=`$CLEARTOOL pwv | grep 'Set view:' | awk -F ': ' '{print $2}'`
    
        export CLEARCASE_VIEW="$CURRENT_VIEW"
        export CTAG_CSCOPE_DEFAULT_VIEW_PATH="$BASE_SRC/build"
    
        if [[ "$CURRENT_VIEW" =~ "NONE" ]]; then
            export CTAG_CSCOPE_PATH=""
        elif [[ "$CURRENT_VIEW" =~ "$USER" ]]; then
            # User owns the view
            export CTAG_CSCOPE_PATH="$CTAG_CSCOPE_DEFAULT_VIEW_PATH"
        else
            # User does not own the view
            export CTAG_CSCOPE_PATH="/tmp/$USER/$CLEARCASE_VIEW"
    
            if [ ! -d "$CTAG_CSCOPE_PATH" ]; then
                mkdir -p "$CTAG_CSCOPE_PATH"
            fi
        fi
    elif [[ "$1" == "mysql" ]]; then
        CURRENT_DIR=`pwd`
    
        export CLEARCASE_VIEW="$USER"
        export CTAG_CSCOPE_DEFAULT_VIEW_PATH="$HOME/.go"
    
        CTAG_CSCOPE_PATH=`get_pathenv $CURRENT_DIR $GOPATH`

        if [[ -z "$CTAG_CSCOPE_PATH" ]]; then
            CTAG_CSCOPE_PATH="$CURRENT_DIR"
        fi

        export CTAG_CSCOPE_PATH
    else
        CURRENT_DIR=`pwd`
    
        export CLEARCASE_VIEW="$USER"
        export CTAG_CSCOPE_DEFAULT_VIEW_PATH="$HOME/.go"
    
        local ctag_cscope_path=`get_pathenv $CURRENT_DIR $GOPATH`

        if [[ -n "$ctag_cscope_path" ]]; then
            CTAG_CSCOPE_PATH="$ctag_cscope_path"
            export CTAG_CSCOPE_PATH
        fi
    fi
}

function find_gosrc_path()
{
    local INPUT_PATH="$1"
    local INPUT_PATH_ARRAY=(${INPUT_PATH//\// })
    local GOSRC=""

    if [[ " ${INPUT_PATH_ARRAY[@]} " =~ " src " ]]; then
        GOSRC=${INPUT_PATH%%/src*}
    fi

    echo $GOSRC
}

function set_gosrc_path()
{
    local GOSRC_PATH=`find_gosrc_path $PWD`
    local GOENV_PATH="$GOBASEPATH"

    if [[ "$GOSRC_PATH" =~ ^.*/GoDCApp/.*$ ]]; then
        GOSRC_PATH=`set_godcapp_gosrc_path $GOSRC_PATH`
    fi

    if [[ -n "$GOSRC_PATH" ]]; then
        if [[ -n "$GOENV_PATH" ]]; then
            GOENV_PATH="$GOSRC_PATH:$GOENV_PATH"
        else
            GOENV_PATH="$GOSRC_PATH"
        fi

        export GOPATH="$GOENV_PATH"

        local GOBIN_PATH="${GOPATH//://bin:}"/bin

        if [[ ! "$PATH" =~ "$GOBIN_PATH" ]]; then
            export PATH="$GOBIN_PATH:$PATH"
        fi	

        set_ctag_cscope_path
    fi
}

function set_godcapp_gosrc_path()
{
    local GODCAPP_NAME="GoDCApp"
    local GOSWITCH="GoSwitch"
    local GODCAPPS=(
        "GoCommon"
        "GoFabric"
        "GoInventory"
        "GoTenant"
        "GoRASlog"
        "GoNotification"
        "GoVCenter"
        "GoHyperV"
        "GoOpenStack"
        "GoSystem"
        "GoAuth"
        "GoRBAC"
        "hostauth")
    local GOSRC_PATH="$1"
    local GOBASE_PATH=${GOSRC_PATH%/$GODCAPP_NAME/*}

    GOSRC_PATH="$GOBASE_PATH/$GODCAPP_NAME/$GOSWITCH"
    
    for GOAPP in "${GODCAPPS[@]}"; do
        GOSRC_PATH="$GOSRC_PATH:$GOBASE_PATH/$GODCAPP_NAME/$GOAPP"
    done

    echo $GOSRC_PATH
}

function match_in_gosrc_path()
{
    local USAGE="match_in_gosrc_path <GOPATH environment variable> <Match string for single go path>"

    if [[ $# -lt 2 || $# -ge 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local IFS=$'\n'
    local GOSRC_PATH="$1"
    local GOPATH_MATCH="$2"
    local GOSRC_PATH_ARRAY=("${(@s/:/)GOSRC_PATH}")

    for gopath in $GOSRC_PATH_ARRAY; do
        if [[ "$gopath" =~ $GOPATH_MATCH ]]; then
            echo "$gopath"
            return
        fi
    done
}

# ZSH FUNCTION HOOKS
if [[ "${0}" == "zsh" ]]; then
    # emulate bash PROMPT_COMMAND (only for zsh)
    preexec() { 
        eval "$PROMPT_COMMAND"; set_gosrc_path 
    }
elif [[ "${0}" == "bash" ]]; then 
    chpwd_functions=(${chpwd_functions[@]} "set_gosrc_path")
fi

# Set an appropriate ctags/cscope path
set_ctag_cscope_path 

# FUNCTIONS

# On-Prem Extreme GitHub
function get_git_token()
{
    local TOKEN=""

    if [[ -f ~/.gittoken ]]; then
        TOKEN=`sed -r 's/\s+//g' ~/.gittoken` 
    fi

    echo "$TOKEN"
}

# Normal GitHub
function get_github_token()
{
    local TOKEN=""

    if [[ -f ~/.githubtoken ]]; then
        TOKEN=`sed -r 's/\s+//g' ~/.githubtoken` 
    fi

    echo "$TOKEN"
}

function git_clone()
{
    local USAGE="git_clone <https://git_repository/path>"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local GIT_URL="$1"
    shift
    local GIT_TOKEN=`get_git_token`

    if [[ "$GIT_URL" =~ ^https://.* ]]; then
        # Do Nothing
        local DO=NOTHING
    else
        echo "$USAGE"
        return 1
    fi

    local GIT_USER=""
    read "GIT_USER?Git Username: "

    local USER=`urlencode $GIT_USER`

    local PASS=""
    if [[ -z "$GIT_TOKEN" ]]; then
        read -s "GIT_PASS?Git Password: "
        PASS=`urlencode $GIT_PASS`
    else
        PASS="$GIT_TOKEN"
    fi

    local NON_HTTPS_URL=${GIT_URL#https://}
    git clone "https://$GIT_USER:$PASS@$NON_HTTPS_URL" $@
}

function clone_godcapp()
{
    local WORKING_DIR=`pwd`
    local GODCAPP_BRANCH="$1"
    local GODCAPP_SOURCE_BRANCH="$2"
    local GODCAPP_DEFAULT_SOURCE_BRANCH="master"
    local GOAUTOSUIT_URL="github.extremenetworks.com/Engineering"
    local GODCAPP_NAME="GoDCApp"
    local GODCAPPS=( "GoSwitch" "GoCommon" "GoFabric" "GoInventory" "GoTenant" "GoRASlog" "GoNotification" "GoVCenter" "GoHyperV" "GoOpenStack" )
    local GIT_TOKEN=`get_git_token`

    if [[ -z "$GODCAPP_SOURCE_BRANCH" ]]; then
        GODCAPP_SOURCE_BRANCH=$GODCAPP_DEFAULT_SOURCE_BRANCH
    fi

    if [[ -z "$GOSWITCH_SOURCE_BRANCH" ]]; then
        GOSWITCH_SOURCE_BRANCH=$GODCAPP_SOURCE_BRANCH
    fi

    local GIT_USER=""
    read "GIT_USER?Git Username: "

    local USER=`urlencode $GIT_USER`

    local PASS=""
    if [[ -z "$GIT_TOKEN" ]]; then
        read -s "GIT_PASS?Git Password: "
        PASS=`urlencode $GIT_PASS`
    else
        PASS="$GIT_TOKEN"
    fi

    # Make and change directory after getting git user credentials
    if [[ -n "$GODCAPP_BRANCH" ]]; then
        mkdir -p "$GODCAPP_BRANCH" 
        cd "$GODCAPP_BRANCH"
    fi

    echo -e "\nCloning https://$USER@$GOAUTOSUIT_URL/$GODCAPP_NAME (Branch: $GODCAPP_SOURCE_BRANCH)"
    if [[ "$GODCAPP_SOURCE_BRANCH" == "$GODCAPP_DEFAULT_SOURCE_BRANCH" ]]; then
        git clone "https://"$USER":"$PASS"@"$GOAUTOSUIT_URL/$GODCAPP_NAME
    else
        #git clone -b $GODCAPP_SOURCE_BRANCH --single-branch "https://"$USER":"$PASS"@"$GOAUTOSUIT_URL/$GODCAPP_NAME
        #git clone -b $GODCAPP_SOURCE_BRANCH "https://"$USER":"$PASS"@"$GOAUTOSUIT_URL/$GODCAPP_NAME
        #git clone --bare "https://"$USER":"$PASS"@"$GOAUTOSUIT_URL/$GODCAPP_NAME
        git clone -b $GODCAPP_DEFAULT_SOURCE_BRANCH "https://"$USER":"$PASS"@"$GOAUTOSUIT_URL/$GODCAPP_NAME
    fi

    if [[ $? -eq 0 ]]; then
        cd $WORKING_DIR/$GODCAPP_BRANCH/$GODCAPP_NAME/${GODCAPPS[1]}/src

        if [[ -n "$GODCAPP_BRANCH" ]]; then
            echo "[Find remote git branch \"$GODCAPP_BRANCH\"...]"
            git branch -r | grep "$GODCAPP_BRANCH"

            if [[ $? -ne 0 ]]; then
                # Create the git branch
                echo "[Create new git branch \"$GODCAPP_BRANCH\"...]"
                git checkout -b "$GODCAPP_BRANCH"
            else
                # Set existing git branch
                echo "[Set existing git branch \"$GODCAPP_BRANCH\"...]"
                git checkout "$GODCAPP_BRANCH"
            fi

            #echo "[Set branch tracking to remote \"$GODCAPP_SOURCE_BRANCH\"...]"
            #git branch --set-upstream-to=origin/$GODCAPP_SOURCE_BRANCH
        fi

        for goapp in "${GODCAPPS[@]}"; do
            cd $WORKING_DIR/$GODCAPP_BRANCH/$GODCAPP_NAME/$goapp/src
            
            set_gosrc_path `pwd`

            echo "[Setup git pre-commit link hooks...]"
            sh ../scripts/link_hooks.sh

            #echo "[Create go ctags/cscope...]"
            #tagscope go_src
        done
    else
        cd $WORKING_DIR && rm -rf "$GODCAPP_BRANCH"
    fi

    cd $WORKING_DIR/$GODCAPP_BRANCH

    if [[ -d "$WORKING_DIR/$GODCAPP_BRANCH/$GODCAPP_NAME/scripts" ]]; then
        cd $WORKING_DIR/$GODCAPP_BRANCH/$GODCAPP_NAME/scripts
    fi
}

function add_godcapp_worktree()
{
    local USAGE="add_godcapp_worktree <Private Branch Name - ex: EFA-12345> <Source Branch>"

    if [[ $# -lt 2 || $# -ge 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local GODCAPP_BRANCH="$1"
    local GODCAPP_SOURCE_BRANCH="$2"
    local GODCAPP_NAME="GoDCApp"
    local RELATIVE_WORKTREE_PATH="../../$GODCAPP_BRANCH/$GODCAPP_NAME"

    pushd "$MASTER_GODCAPP_SRC" > /dev/null

    git pull && \
    git checkout "$GODCAPP_SOURCE_BRANCH" && \
    git pull && \
    git worktree add -b "$USER/$GODCAPP_BRANCH" "$RELATIVE_WORKTREE_PATH" && \
    git checkout master && \
    cd "$RELATIVE_WORKTREE_PATH" && \
    git branch --set-upstream-to=origin/"$GODCAPP_SOURCE_BRANCH"
    #go_work
}

function remove_godcapp_worktree()
{
    local USAGE="remove_godcapp_worktree <Private Branch Name - ex: EFA-12345>"

    if [[ $# -lt 1 || $# -ge 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local GODCAPP_BRANCH="$1"
    local GODCAPP_NAME="GoDCApp"
    local RELATIVE_WORKTREE_PATH="../../$GODCAPP_BRANCH/$GODCAPP_NAME"

    pushd "$MASTER_GODCAPP_SRC" > /dev/null

    sudo git worktree remove --force "$MASTER_GODCAPP_SRC/$RELATIVE_WORKTREE_PATH" && \
    git branch -D "$USER/$GODCAPP_BRANCH"

    popd > /dev/null 2>&1

    sudo rm -rf $(dirname "$MASTER_GODCAPP_SRC/$RELATIVE_WORKTREE_PATH")
}

function list_godcapp_worktree()
{
    pushd "$MASTER_GODCAPP_SRC" > /dev/null

    git worktree list

    popd > /dev/null 2>&1
}

function go_work()
{
    go work init && find . -type f ! -path '*/pkg/*' -name go.mod -execdir echo '.'${$(pwd)##*/GoDCApp} \; | xargs go work use
}

function scp_cloud() {
    local USAGE="scp_cloud <Cloud test bed filename - ex: ws2r1|nvo1r1:/filename> <Destination filename>"

    if [[ $# -lt 1 || $# -gt 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "${USAGE}"
        return 1
    fi

    local CLOUD_JUMPHOST1="usnh-awsgtwy-02.extremenetworks.com"
    local CLOUD_JUMPHOST2="usnc-awsgtwy-02.extremenetworks.com"
    local SRC_FILENAME="${1}"
    local DST_INPUT="${2}"
    local DST_FILENAME=$(realpath ${DST_FILENAME})

    if [[ ! -d "${DST_FILENAME}" && ! -f "${DST_FILENAME}" ]]; then
        echo -n "${USAGE}\n\nDestination path: ${DST_INPUT} does not exist!\n"
        return 2
    fi

    local CLOUD_HOST_PREFIX="${SRC_FILENAME%%:*}"
    local CLOUD_FILENAME="${SRC_FILENAME#*:}"
    local CLOUD_HOSTNAME="${CLOUD_HOST_PREFIX}-console.qa.xcloudiq.com"
    local SRC_CLOUD_HOST_FILENAME="${CLOUD_HOSTNAME}:${CLOUD_FILENAME}"
    local SRC_CLOUD_FILENAME="$(basename ${CLOUD_FILENAME})"
    local MY_HOST_IP=$(HOST_IP=`ifconfig | awk '/inet / {print $2}' | sed -n 's/.*\(134.[0-9]\+.[0-9]\+.[0-9]\+\).*/\1/p'`; if [[ "${HOST_IP}" == "" ]]; then HOST_IP=`ifconfig | awk '/inet / {print $2}' | sed -n 's/.*\(10.[0-9]\+.[0-9]\+.[0-9]\+\).*/\1/p' | grep -v "10.42.0."`; fi; echo ${HOST_IP})

    echo "ssh -A -t ${CLOUD_JUMPHOST1} \"scp ${SRC_CLOUD_HOST_FILENAME} ${SRC_CLOUD_FILENAME} && scp ${SRC_CLOUD_FILENAME} $USER@${MY_HOST_IP}:${DST_FILENAME} && rm ${SRC_CLOUD_FILENAME}\""
    ssh -A -t ${CLOUD_JUMPHOST1} "scp ${SRC_CLOUD_HOST_FILENAME} ${SRC_CLOUD_FILENAME} && scp ${SRC_CLOUD_FILENAME} $USER@${MY_HOST_IP}:${DST_FILENAME} && rm ${SRC_CLOUD_FILENAME}"
}

# nvo_cloud_get_logs - Assumes 'nvo_cloud_support_save.sh' is available in the user's path on the cloud testbed 
function nvo_cloud_support_save() {
    local USAGE="nvo_cloud_support_save <Cloud test bed name - ex: ws2r1|nvo1r1> <Destination directory>"

    if [[ $# -lt 1 || $# -gt 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "${USAGE}"
        return 1
    fi

    local CLOUD_HOST_PREFIX="${1}"
    local DST_INPUT="${2}"
    local JUMPHOST_SELECTION="${3}"

    # NorthCarolina jumphost seems to perform better than NewNampshire
    local CLOUD_JUMPHOST1="usnh-awsgtwy-02.extremenetworks.com"
    local CLOUD_JUMPHOST2="usnc-awsgtwy-02.extremenetworks.com"
    local CLOUD_JUMPHOST="${CLOUD_JUMPHOST1}"
    local DST_FILENAME=$(realpath ${DST_INPUT})

    # Input Validations
    if [[ ! -d "${DST_FILENAME}" && ! -f "${DST_FILENAME}" ]]; then
        echo -n "${USAGE}\n\nDestination path: ${DST_INPUT} does not exist!\n"
        return 2
    fi

    if [[ ${JUMPHOST_SELECTION} -eq 2 ]]; then
        CLOUD_JUMPHOST="${CLOUD_JUMPHOST2}"
    fi

    local SRC_FILENAME="${CLOUD_HOST_PREFIX}:~/nvo-${CLOUD_HOST_PREFIX}*.tgz"
    local CLOUD_FILENAME="${SRC_FILENAME#*:}"
    local CLOUD_HOSTNAME="${CLOUD_HOST_PREFIX}-console.qa.xcloudiq.com"
    local SRC_CLOUD_HOST_FILENAME="${CLOUD_HOSTNAME}:${CLOUD_FILENAME}"
    local SRC_CLOUD_FILENAME="$(basename ${CLOUD_FILENAME})"
    local MY_HOST_IP=$(HOST_IP=`ifconfig | awk '/inet / {print $2}' | sed -n 's/.*\(134.[0-9]\+.[0-9]\+.[0-9]\+\).*/\1/p'`; if [[ "${HOST_IP}" == "" ]]; then HOST_IP=`ifconfig | awk '/inet / {print $2}' | sed -n 's/.*\(10.[0-9]\+.[0-9]\+.[0-9]\+\).*/\1/p' | grep -v "10.42.0."`; fi; echo ${HOST_IP})

    echo "ssh -A -t ${CLOUD_JUMPHOST} \"ssh -t ${CLOUD_HOSTNAME} \\\"bash -l -c 'nvo_cloud_support_save.sh'\\\" && scp ${SRC_CLOUD_HOST_FILENAME} . && scp ${SRC_CLOUD_FILENAME} $USER@${MY_HOST_IP}:${DST_FILENAME} && ssh -t ${CLOUD_HOSTNAME} \\\"bash -l -c 'rm ${SRC_CLOUD_FILENAME}'\\\" && rm ${SRC_CLOUD_FILENAME}\""
    ssh -A -t ${CLOUD_JUMPHOST} "ssh -t ${CLOUD_HOSTNAME} \"bash -l -c 'nvo_cloud_support_save.sh'\" && scp ${SRC_CLOUD_HOST_FILENAME} . && scp ${SRC_CLOUD_FILENAME} $USER@${MY_HOST_IP}:${DST_FILENAME} && ssh -t ${CLOUD_HOSTNAME} \"bash -l -c 'rm ${SRC_CLOUD_FILENAME}'\" && rm ${SRC_CLOUD_FILENAME}"
}

function efa_repl()
{
    local USAGE="efa_repl - Should be executed anywhere under the GoDCApp directory"
    local GOWORK=`go env GOWORK`

    if [[ -z $GOWORK ]]; then
        echo "$USAGE"
        return 1
    fi

    local GOWORK_DIR=`dirname ${GOWORK}`
    local EFA_REPL_DIR="${GOWORK_DIR}/scripts/k3s-deployment"

    pushd "$EFA_REPL_DIR" > /dev/null

    export EFA_LOG_TO_STDOUT=1

    source common.sh && initialize_deployment_global_env

    popd > /dev/null 2>&1
}

swagger_codegen()
{
    java -jar /usr/bin/swagger-codegen-cli.jar "$@"
}

inventory_swagger_gen()
{
    local USAGE="inventory_swagger_gen [all | client | server | html]"

    if [[ $# -lt 1 || $# -ge 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local WORKING_DIR=`pwd`
    local GOAPP_INVENTORY="GoInventory"
    local GOPATH_INVENTORY=`match_in_gosrc_path $GOPATH $GOAPP_INVENTORY`
    local TYPE="$1"

    if [[ -z "$TYPE" ]]; then
        TYPE="all"
    fi

    if [[ -n GOPATH_INVENTORY ]]; then
        cd $GOPATH_INVENTORY

        if [[ "$TYPE" == "all" || "$TYPE" == "client" || "$TYPE" == "server" || "$TYPE" == "html" ]]; then
            swagger_codegen generate -i ./src/inventory/rest/openapi.yaml -l html -o ./src/inventory/rest/generated/html
        fi

        if [[ "$TYPE" == "all" || "$TYPE" == "client" ]]; then
            swagger_codegen generate -i ./src/inventory/rest/openapi.yaml -l go -o ../GoCommon/src/inventoryclient/swagger
        fi

        if [[ "$TYPE" == "all" || "$TYPE" == "server" ]]; then
            swagger_codegen generate -i ./src/inventory/rest/openapi.yaml -l go-server -o ./src/inventory/rest/generated/server
        fi

        cd $WORKING_DIR
    else
        echo "GOPATH ENV: \"$GOPATH\" is not configured for $GOAPP_INVENTORY service."
    fi
}

inventory_pq2gorm_gen()
{
    local USAGE="inventory_pq2gorm_gen [pq2gorm params: -t <table names> -d <output dir>]"

    if [[ "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    pq2gorm_gen dcapp_asset $@
}

pq2gorm_gen()
{
    local USAGE="pq2gorm_gen <GoDCApp DB name> [pq2gorm params: -t <table names> -d <output dir>]"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local POSTGRES_DBNAME="$1"
    shift

    local POSTGRES_USER="postgres"
    local POSTGRES_PASS="password"
    local POSTGRES_IPPORT=`get_k3sdb_ipport`
    local POSTGRESQL_URL=`get_postgresql_url $POSTGRES_USER $POSTGRES_PASS $POSTGRES_DBNAME`

    echo pq2gorm "$POSTGRESQL_URL" $@
    pq2gorm "$POSTGRESQL_URL" $@
}

inventory_migrate_db()
{
    local USAGE="inventory_migrate_db <path to migration sql files> <up|down>"

    if [[ $# -lt 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local POSTGRES_USER="asset"
    local POSTGRES_PASS="asset"
    local POSTGRES_DBNAME="dcapp_asset"
    local DIRECTORY="$1"
    shift

	migrate_db "$POSTGRES_USER" "$POSTGRES_PASS" "$POSTGRES_DBNAME" "$DIRECTORY" $@
}

migrate_db()
{
    local USAGE="migrate_db <postgres user> <postgres pass> <postgres db name> <path to migration sql files> <migrate command args>"

    if [[ $# -lt 5 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local POSTGRES_USER="$1"
    shift
    local POSTGRES_PASS="$1"
    shift
    local POSTGRES_DBNAME="$1"
    shift
    local DIRECTORY="$1"
    shift
    local POSTGRESQL_URL=`get_postgresql_url $POSTGRES_USER $POSTGRES_PASS $POSTGRES_DBNAME`

    echo "migrate -path $DIRECTORY -database \"$POSTGRESQL_URL\" $@"
    migrate -path "$DIRECTORY" -database "$POSTGRESQL_URL" $@
}

get_postgresql_url() 
{
    local USAGE="get_postgresql_url <postgres user> <postgres pass> <postgres db name>"

    if [[ $# -lt 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local POSTGRES_USER="$1"
    local POSTGRES_PASS="$2"
    local POSTGRES_DBNAME="$3"
    local POSTGRES_IPPORT=`get_k3sdb_ipport`

    echo "postgresql://$POSTGRES_USER:$POSTGRES_PASS@$POSTGRES_IPPORT/$POSTGRES_DBNAME?sslmode=disable"
}

enable_nonroot_k3s() {
    sudo chmod 777 /etc/rancher/k3s/k3s.yaml
}

get_k3sdb_ipport()
{
    k3s kubectl -n efa get service | grep db-service | awk '{split($5,port,":");print $3":"port[1]}'
}

set_efa_env()
{
    local INPUT_PORT="$1"

    export DCA_SERVER_BASEPATH=`host_ip`:$INPUT_PORT
}

set_dbk3s_env()
{
    local DBSERVICE_NAME="db-service"
    local MESSAGE_BUS_NAME="rabbitmq"
    
    export DBHOST=`k3s kubectl -n efa get services | grep $DBSERVICE_NAME | awk '{print $3}'`
    export MessageBusHost=`k3s kubectl -n efa get services | grep $MESSAGE_BUS_NAME | awk '{print $3}'`
}

godcapp_docker_pull()
{
    local USAGE="godcapp_docker_pull [registry name | nil]"

    local WORKING_DIR=`pwd`
    local REGISTRY_INPUT="$1"
    local DOCKER_REGISTRY="godcfregistry.extremenetworks.com/godcapp/"
    local VERSION="$USER-latest"
    local GODCAPP_NAME="GoDCApp"
    local GODCAPP_PATH=`match_in_gosrc_path $GOPATH $GODCAPP_NAME`
    GODCAPP_PATH=`dirname "$GODCAPP_PATH"`

    local GODCAPP_SCRIPTS_PATH="$GODCAPP_PATH/scripts"
    local GODCAPP_API_SCRIPTS_PATH="$GODCAPP_SCRIPTS_PATH/single-node-deployment/api-scripts"
    local GODCAPP_ELK_PATH="$GODCAPP_SCRIPTS_PATH/single-node-deployment/elk"
    local ELK_VERSION="6.4.2"

    local POSTGRES_CONTAINER_VERSION="9.6"
    local KONGA_CONTAINER_VERSION="next"
    local KONG_CONTAINER_VERSION="1.0.0-alpine"
    local RABBITMQ_CONTAINER_VERISON="3-management"
    local METRICBEAT_CONTAINER_VERSION="6.6.0"

    if [[ "$REGISTRY_INPUT" == "nil" ]]; then
        DOCKER_REGISTRY=""
    elif [[ -z "$REGISTRY_INPUT" ]]; then
        DOCKER_REGISTRY="$REGISTRY_INPUT"
    fi

    if [[ -z "$GODCAPP_PATH" ]]; then
        echo "Cannot find the GoDCApp path from GOPATH: $GOPATH"
        return
    fi

    cd "$GODCAPP_SCRIPTS_PATH"
    
    docker pull "$DOCKER_REGISTRY"postgres:"$POSTGRES_CONTAINER_VERSION"
    docker pull "$DOCKER_REGISTRY"konga:"$KONGA_CONTAINER_VERSION" && docker tag "$DOCKER_REGISTRY"konga:"$KONGA_CONTAINER_VERSION" konga:latest
    docker pull "$DOCKER_REGISTRY"kong:"$KONG_CONTAINER_VERSION" && docker tag "$DOCKER_REGISTRY"kong:"$KONG_CONTAINER_VERSION" kong:latest && docker rmi "$DOCKER_REGISTRY"kong:1.0.0-alpine
    docker pull "$DOCKER_REGISTRY"rabbitmq:"$RABBITMQ_CONTAINER_VERISON" && docker tag "$DOCKER_REGISTRY"rabbitmq:"$RABBITMQ_CONTAINER_VERISON" rabbitmq:latest
    docker pull "$DOCKER_REGISTRY"metricbeat:"$METRICBEAT_CONTAINER_VERSION" && docker tag "$DOCKER_REGISTRY"metricbeat:"$METRICBEAT_CONTAINER_VERSION" elk_metricbeat:latest

    cd "$GODCAPP_API_SCRIPTS_PATH" && docker build -t configureapis:latest .
    cd "$GODCAPP_ELK_PATH/logstash" && docker build --build-arg ELK_VERSION="$ELK_VERSION" -t elk_logstash .
    cd "$GODCAPP_ELK_PATH/filebeat" && docker build -t elk_filebeat .
    cd "$GODCAPP_ELK_PATH/elasticsearch" && docker build --build-arg ELK_VERSION="$ELK_VERSION" -t elk_elasticsearch .
    cd "$GODCAPP_ELK_PATH/kibana" && docker build --build-arg ELK_VERSION="$ELK_VERSION" -t elk_kibana .
    
    cd "$GODCAPP_PATH"

    echo "building GoInventory image"
    bash GoInventory/scripts/build_docker.sh
    echo "building GoTenant image"
    bash GoTenant/scripts/build_docker.sh
    echo "building GoFabric image"
    bash GoFabric/scripts/build_docker.sh
    echo "building GoSwitch image"
    cp -r $GODCAPP_PATH/../GoSwitch .
    bash GoSwitch/scripts/build_docker.sh
    echo "building postgres image"
    docker build -t postgres-db -f scripts/single-node-deployment/database-scripts/Dockerfile ./..

    cd "$WORKING_DIR"
}

godcapp_docker()
{
    local USAGE="godcapp_docker <host ip address> [all | inventory | fabric | tenant] [container version]"

    if [[ $# -lt 1 || $# -ge 4 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local HOST_IP="$1"
    local GODCAPP_SERVICE="$2"
    local GODCAPP_VERSION="$3"
    #local GODCAPP_REGISTRY="godcfregistry.extremenetworks.com/godcapp/"
    local GODCAPP_REGISTRY=""
    local GODCAPP_NAME="GoDCApp"
    local GODCAPP_PATH=`match_in_gosrc_path $GOPATH $GODCAPP_NAME`
    GODCAPP_PATH=`dirname $GODCAPP_PATH`

    local RABBITMQ_VERSION="3-management"
    local POSTGRES_VERSION="9.6"

    local RABBITMQ_CONTAINER_NAME="rabbitmq-$GODCAPP_VERSION"
    local POSTGRES_CONTAINER_NAME="postgres-database-$GODCAPP_VERSION"
    local GOINVENTORY_CONTAINER_NAME="goinventory-$GODCAPP_VERSION"
    local GOFABRIC_CONTAINER_NAME="gofabric-$GODCAPP_VERSION"
    local GOTENANT_CONTAINER_NAME="gotenant-$GODCAPP_VERSION"

    if [[ -z "$GODCAPP_SERVICE" ]]; then
        GODCAPP_SERVICE="all"
    fi

    if [[ -z "$GODCAPP_VERSION" ]]; then
        GODCAPP_VERSION="v2.1.0-9"
    fi

    if [[ $GOPATH =~ $GODCAPP_NAME ]]; then 
        echo docker run -d --hostname dcapp-message-bus -p 5672:5672 -p 15672:15672 -e RABBITMQ_ERLANG_COOKIE='SWQOKODSQALRPCLNMEQG' -e RABBITMQ_DEFAULT_USER=rabbitmq -e RABBITMQ_DEFAULT_PASS=rabbitmq --name "$RABBITMQ_CONTAINER_NAME" "$GODCAPP_REGISTRY"rabbitmq:"$RABBITMQ_VERSION"
        docker run -d --hostname dcapp-message-bus -p 5672:5672 -p 15672:15672 -e RABBITMQ_ERLANG_COOKIE='SWQOKODSQALRPCLNMEQG' -e RABBITMQ_DEFAULT_USER=rabbitmq -e RABBITMQ_DEFAULT_PASS=rabbitmq --name "$RABBITMQ_CONTAINER_NAME" "$GODCAPP_REGISTRY"rabbitmq:"$RABBITMQ_VERSION"

        echo docker run -d -p 5432:5432 -v $GODCAPP_PATH/GoInventory/etc:/inventory/etc -v $GODCAPP_PATH/GoInventory/scripts:/inventory/scripts --name "$POSTGRES_CONTAINER_NAME" -e POSTGRES_PASSWORD=password "$GODCAPP_REGISTRY"postgres:"$POSTGRES_VERSION"
        docker run -d -p 5432:5432 -v $GODCAPP_PATH/GoInventory/etc:/inventory/etc -v $GODCAPP_PATH/GoInventory/scripts:/inventory/scripts --name "$POSTGRES_CONTAINER_NAME" -e POSTGRES_PASSWORD=password "$GODCAPP_REGISTRY"postgres:"$POSTGRES_VERSION"


        echo docker exec -it "$POSTGRES_CONTAINER_NAME" bash -c "chmod u+x /inventory/scripts/dcapp_psql_setup.sh&&apt-get update && apt-get -y install sudo&&cd /inventory/scripts&&./dcapp_psql_setup.sh"
        docker exec -it "$POSTGRES_CONTAINER_NAME" bash -c "chmod u+x /inventory/scripts/dcapp_psql_setup.sh&&apt-get update && apt-get -y install sudo&&cd /inventory/scripts&&./dcapp_psql_setup.sh"

        echo "Waiting for base services to come up..."
        sleep 1

        if [[ "$GODCAPP_SERVICE" == "all" || "$GODCAPP_SERVICE" == "inventory" || "$GODCAPP_SERVICE" == "fabric" || "$GODCAPP_SERVICE" == "tenant" ]]; then
            echo docker run -d -p 8082:8082 --env DBHOST="$HOST_IP" --env MessageBusHost="$HOST_IP" --name "$GOINVENTORY_CONTAINER_NAME" "$GODCAPP_REGISTRY"goinventory:"$GODCAPP_VERSION"
            docker run -d -p 8082:8082 --env DBHOST="$HOST_IP" --env MessageBusHost="$HOST_IP" --name "$GOINVENTORY_CONTAINER_NAME" "$GODCAPP_REGISTRY"goinventory:"$GODCAPP_VERSION"
        fi

        if [[ "$GODCAPP_SERVICE" == "all" || "$GODCAPP_SERVICE" == "fabric" ]]; then
            echo docker run -d -p 8081:8081 --env DBHOST="$HOST_IP" --env MessageBusHost="$HOST_IP" --name "$GOFABRIC_CONTAINER_NAME" "$GODCAPP_REGISTRY"gofabric:"$GODCAPP_VERSION"
            docker run -d -p 8081:8081 --env DBHOST="$HOST_IP" --env MessageBusHost="$HOST_IP" --name "$GOFABRIC_CONTAINER_NAME" "$GODCAPP_REGISTRY"gofabric:"$GODCAPP_VERSION"
        fi

        if [[ "$GODCAPP_SERVICE" == "all" || "GODCAPP_SERVICE" == "tenant" ]]; then
            echo docker run -d -p 8083:8083 --env DBHOST="$HOST_IP" --env MessageBusHost="$HOST_IP" --name "$GOTENANT_CONTAINER_NAME" "$GODCAPP_REGISTRY"gotenant:"$GODCAPP_VERSION"
            docker run -d -p 8083:8083 --env DBHOST="$HOST_IP" --env MessageBusHost="$HOST_IP" --name "$GOTENANT_CONTAINER_NAME" "$GODCAPP_REGISTRY"gotenant:"$GODCAPP_VERSION"
        fi
    else
        echo "GOPATH ENV: \"$GOPATH\" is not under $GODCAPP_NAME."
    fi
}

ps_docker()
{
    local USAGE="ps_docker [container|image|names]"
    INPUT="$1"

    if [[ "$INPUT" == "help" ]]; then
        echo "$USAGE"
        return 1
    fi
    
    if [[ -z "$INPUT" ]]; then
        INPUT="container"
    fi

    if [[ "$INPUT" == "container" ]]; then
        docker ps -a --format "{{.ID}}"
    elif [[ "$INPUT" == "image" ]]; then
        docker ps -a --format "table {{.ID}}\t{{.Image}}"
    elif [[ "$INPUT" == "names" ]]; then
        docker ps -a --format "table {{.ID}}\t{{.Names}}\t{{.Image}}"
    fi 
}

rm_docker()
{
    local USAGE="rm_docker <all | container id>"
    INPUT="$1"

    if [[ $# -lt 1 || $# -ge 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    if [[ "$INPUT" == "all" ]]; then 
        for container_id in `ps_docker`; do
            docker rm -vf $container_id
        done
    else
        docker rm -vf "$INPUT"
    fi
}

exec_docker()
{
    local USAGE="exec_docker <container id or name> [shell]"

    if [[ $# -lt 1 || $# -ge 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local CONTAINER="$1"   
    local INSHELL="$2"

    if [[ -z "$INSHELL" ]]; then
        INSHELL="ash"
    fi 

    echo docker exec -it "$CONTAINER" "$INSHELL"
    docker exec -it "$CONTAINER" "$INSHELL"
}

ps_kube()
{
    get_kube pods "$@"
}

get_kube()
{
    local USAGE="get_kube [options]"

    local OPTIONS="$1"

    if [[ "$OPTIONS" == "help" ]]; then
        echo "$USAGE"
        return 1
    fi

    #echo k3s kubectl -n efa get "$@"
    k3s kubectl -n efa get "$@"
}

rm_kube()
{
    local USAGE="rm_kube <service name>"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local SERVICE_NAME="$1"
    local KUBE_SERVICES=(`k3s kubectl -n efa get all | tac | awk '{print $1}' | grep $SERVICE_NAME`)

    echo "KUBE_SERVICES:" 

    for service in "${KUBE_SERVICES[@]}"; do
        echo "- $service"
        k3s kubectl -n efa delete $service
    done
}

delete_kube()
{
    local USAGE="delete_kube [options]"

    local OPTIONS="$1"

    if [[ "$OPTIONS" == "help" ]]; then
        echo "$USAGE"
        return 1
    fi

    #echo k3s kubectl -n efa delete "$@"
    k3s kubectl -n efa delete "$@"
}

create_kube()
{
    local USAGE="create_kube [options]"

    local OPTIONS="$1"

    if [[ "$OPTIONS" == "help" ]]; then
        echo "$USAGE"
        return 1
    fi

    k3s kubectl -n efa create "$@"
}

apply_kube()
{
    local USAGE="apply_kube [options]"

    local OPTIONS="$1"

    if [[ "$OPTIONS" == "help" ]]; then
        echo "$USAGE"
        return 1
    fi

    k3s kubectl -n efa apply "$@"
}

describe_kube()
{
    local USAGE="describe_kube [options]"

    local OPTIONS="$1"

    if [[ "$OPTIONS" == "help" ]]; then
        echo "$USAGE"
        return 1
    fi

    k3s kubectl -n efa describe "$@"
}

exec_kube()
{
    local USAGE="exec_kube <pod name> [shell]"

    if [[ $# -lt 1 || $# -ge 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local PODNAME="$1"
    local INSHELL="$2"

    if [[ -z "$INSHELL" ]]; then
        INSHELL="ash"
    fi

    local CONTAINER=`ps_kube | grep $PODNAME | cut -d ' ' -f 1`

    echo k3s kubectl -n efa exec "$CONTAINER" -it -- "$INSHELL"
    k3s kubectl -n efa exec "$CONTAINER" -it -- "$INSHELL"
}

log_kube()
{
    local USAGE="log_kube <pod name> [options]"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local CONTAINER="$1"
    shift
    local OPTIONS="$@"

    echo k3s kubectl -n efa logs "$CONTAINER" "$@"
    k3s kubectl -n efa logs "$CONTAINER" "$@"
}

set_term_title()
{
    echo -en "\033]0;$1\a"
}

update_gopls()
{
    local USAGE="update_gopls [version]"

    local VERSION="$1"

    if [[ "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
	fi

    if [[ -z "$VERSION" ]]; then
       VERSION="latest"
    fi

    ORIGINAL_GOPATH="$GOPATH"
    GOPATH="$GOBASEPATH"
    
    GO111MODULE=on go get golang.org/x/tools/gopls@"$VERSION"   

    GOPATH="$ORIGINAL_GOPATH"
}

setup_tmuxinator()
{
    local USAGE="setup_tmuxinator <username> <host ip> [rme]"

    local USER="$1"
    local HOST_IP="$2"
    local TMUX_OPTION="$3"
    local SSH_OPTIONS="-o StrictHostKeyChecking=no"
    local YAML_FILE="efa.yml"
    local INPUT_YAML_FILE="${YAML_FILE}"

    if [[ $# -lt 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    if [[ "${TMUX_OPTION}" == "rme" ]]; then
        INPUT_YAML_FILE="efatpvm_rme.yml"
    elif [[ "${USER}" == "extreme" ]]; then
        INPUT_YAML_FILE="efatpvm.yml"
    fi

    #+setup_tmuxinator:20> ssh '-o StrictHostKeyChecking=no' ubuntu@10.177.205.215 'bash -c "sudo apt install tmuxinator tmux -y; sudo sh -c '\''echo set -g pane-border-format \\\"#{pane_index} \#{pane_title}\\\" > /root/.tmux.conf'\''; sudo sh -c '\''echo set -g pane-border-status top >> /root/.tmux.conf'\''"'

    local MY_PUB_KEY=`cat ~/.ssh/id_rsa.pub`
    
    ssh $SSH_OPTIONS $USER@$HOST_IP "bash -c \"echo $MY_PUB_KEY >> /home/$USER/.ssh/authorized_keys\""

    ssh $SSH_OPTIONS $USER@$HOST_IP "bash -c \"sudo apt install tmuxinator tmux sysstat -y; sudo sh -c 'echo set -g pane-border-format \\\\\\\"#{pane_index} \#{pane_title}\\\\\\\" > /root/.tmux.conf'; sudo sh -c 'echo set -g pane-border-status top >> /root/.tmux.conf'\""
    scp ~/proj/efa/tmuxinator/$INPUT_YAML_FILE $USER@$HOST_IP:~/$YAML_FILE
    ssh $SSH_OPTIONS $USER@$HOST_IP "bash -c \"sudo sh -c 'if [ ! -d /root/.tmuxinator ] ; then mkdir /root/.tmuxinator; fi && mv -f /home/$USER/$YAML_FILE /root/.tmuxinator/'\""
}

function git-ls-lrt ()
{
    for k in `git branch | sed s/^..//`; do
        echo -e `git log -1 --pretty=format:"%Cgreen%ci %Cblue%cr%Creset" "$k" 2>/dev/null`\\t"$k";
    done | sort -r | less -r
}

function test_openapi()
{
    local USAGE="test_openapi <rack1|rack1dt|rack2|rack2dt|<Inlets Server IP> <Device Serial #'s - comma separated>> <openapi path: ex - state/system>"

    local RACK="$1"
    local OPENAPI_PATH="$2"

    if [[ $# -lt 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local RACK1=(
        "2043F-20305"
        "SB032050G-00144"
        "SB052102G-00063"
        "SB052102G-00081"
        "SB062048G-00172"
        "2025G-00028"
        "1947Q-40223"
        "1947Q-40263"
        "2043F-20306"
        "SB062048G-00029"
        "SB062048G-00185"
        "2043F-20313"
    )
    local RACK1_DT=(
        "SIM512001-92120"
        "SIM512001-92115"
        "SIM512001-92116"
        "SIM512001-92117"
        "SIM512001-92111"
        "SIM512001-92112"
        "SIM512001-92118"
        "SIM512001-92119"
        "SIM512001-92122"
        "SIM512001-92113"
        "SIM512001-92114"
        "SIM512001-92121"
    )
    local RACK2=(
        "TB012301K-H0087"
        "JA012302G-00272"
        "JA012301G-00047"
        "AR022302Q-40002"
        "AR022302Q-40016"
        "SB032050G-00050"
        "SB022248G-00068"
        "TB012301K-H0697"
        "2306Q-40144"
        "2306Q-40050"
        "2042F-20961"
        "JA062301G-00343" # Stack Primary
        #"JA062301G-00337" Stack Member
        #"JA062301G-00314" Stack Member
    )
    local RACK2_DT=(
        "SIM512000-19288"
        "SIM512000-19290"
        "SIM512000-19289"
        "SIM512000-19281"
        "SIM512000-19282"
        "SIM512000-19285"
        "SIM512000-19286"
        "SIM512000-19287"
        "SIM512000-19283"
        "SIM512000-19284"
        "SIM512000-19291"
        "SIM512000-19292"
        "SIM512000-19293"
        "SIM512000-19294"
        "SIM512000-19295" # Stack Primary
    )

    local INLET_SERVER_IP=""
    local INLET_SERVER_PORT="8090"

    if [[ "${RACK}" == "rack1" ]]; then 
        INLET_SERVER_IP="10.64.194.54"
        RACK=(${RACK1[@]})
    elif [[ "${RACK}" == "rack1dt" ]]; then
        INLET_SERVER_IP="10.64.194.53"
        RACK=(${RACK1_DT[@]})
    elif [[ "${RACK}" == "rack2" ]]; then
        INLET_SERVER_IP="10.64.194.52"
        RACK=(${RACK2[@]})
    elif [[ "${RACK}" == "rack2dt" ]]; then
        INLET_SERVER_IP="10.64.194.51"
        RACK=(${RACK2_DT[@]})
    else
        INLET_SERVER_IP="$1"
        if [[ "$INLET_SERVER_IP" =~ : ]]; then
            INLET_SERVER_PORT=${INLET_SERVER_IP##*:}
            INLET_SERVER_IP=${INLET_SERVER_IP%%:*}
        fi
 
        # Zsh only
        RACK=(${(@s:,:)2})
        # Bash only
        #RACK=(${2//,/ })
        OPENAPI_PATH="$3"
    fi

    for i in ${RACK[@]}; do
        echo "DEVICE SERIAL NUMBER: $i"
        # Remove any starting forward slashes from OPENAPI_PATH
        echo "curl -f -H \"host:openapi.$i\" -X 'GET' http://${INLET_SERVER_IP}:${INLET_SERVER_PORT}/rest/openapi/v0/${OPENAPI_PATH#/}"
        curl -f -H "host:openapi.$i" -X 'GET' http://${INLET_SERVER_IP}:${INLET_SERVER_PORT}/rest/openapi/v0/${OPENAPI_PATH#/}
    done
}

function ssdecode()
{
    SOURCE_DIR="$1"

    SOURCE_PARTS=(${SOURCE_DIR//\// })
    LAST_DIR=${SOURCE_PARTS[${#SOURCE_PARTS[@]} - 1]}
    
    if [ ! -d "$SS_PATH/$LAST_DIR" ]; then
        echo "[Creating directory \"$SS_PATH/$LAST_DIR\" ...]"
        mkdir -p $SS_PATH/$LAST_DIR
    else
        echo "[Directory \"$SS_PATH/$LAST_DIR\" already exists.  Cleaning directory before copying ...]"
        rm -rf $SS_PATH/$LAST_DIR/*
    fi

    echo "[Copying \"$SOURCE_DIR\" to \"$SS_PATH/$LAST_DIR\" ...]"
    cp -r $SOURCE_DIR/* $SS_PATH/$LAST_DIR

    echo "[Decoding supportsave \"$SS_PATH/$LAST_DIR\" ...]"
    cd $SS_PATH/$LAST_DIR
    #~swuser/bin/ssdecode.sh $SS_PATH/$LAST_DIR
    $HOME/proj/platform/scripts/ssdecode.sh $SS_PATH/$LAST_DIR

    #wait ${!}
    `echo -e "\n"`
    echo "[Supportsave decode complete]"
}

function supportsave_swbd()
{
    OS_FILES=`ls -1 | grep "OS.txt$"`

    for i in $OS_FILES; do
        echo -e "\nFILENAME: $i"
        grep -A 12 "\/sbin\/sin" $i 
    done
}

function supportsave_firmware()
{
    INFRA_FILES=`ls -1 | grep "INFRA.txt$"`

    for i in $INFRA_FILES; do
        echo -e "\nFILENAME: $i"
        grep -A 50 "firmwareshow -a" $i
    done
}

function is_xauth_locked()
{
    local IS_XAUTH_LOCKED="yes"

    IS_XAUTH_LOCKED=`xauth info | grep "File locked" | awk '{print $3}'`

    echo $IS_XAUTH_LOCKED
}

function wait_for_xauth_lock()
{
    local IS_XAUTH_LOCKED=`is_xauth_locked`

    while [ "$IS_XAUTH_LOCKED" != "no" ]; do
        IS_XAUTH_LOCKED=`is_xauth_locked`
        sleep 0.2
    done
}

function clean_start_dcm()
{
    local DCM_NUMBER="$1"
    local STARTDCM="$BASE_SRC/fabos/src/vcs/dcm/application/startdcm"

    if [[ ! "$DCM_NUMBER" =~ ^[0-9]+$ ]]; then
        local ALL_PARAMETERS="$@"
        DCM_NUMBER=`expr "$ALL_PARAMETERS" : '.*dcmn=\([0-9]\+\).*'`
    fi

    kill_dcmd_pids "$DCM_NUMBER"
    sleep 1
    rm -rf WaveDatabase *trc* *log *conf *cfg* *pgd startupFile ccm; rm -rf ../node$DCM_NUMBER; sync

    "$STARTDCM" "$@"
}

function kill_dcmd_pids()
{
    local USAGE="kill_dcmd_pids [Signal: -#] [DCM Number Instance: If no specific instance provided then ALL instances under the user will be included.]"

    if [[ $# -ge 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local SIGNAL="-15"

    if [[ "$1" =~ ^-[0-9]+$ ]]; then
        SIGNAL="$1"
        shift
    fi

    local DCM_NUMBER="$1"
    local DCM_PIDS=`ls_dcm_pids "$DCM_NUMBER"`

    if [[ -n "$DCM_PIDS" ]]; then
        kill $SIGNAL $DCM_PIDS

        sleep 0.5

        DCM_PIDS=`ls_dcm_pids "$DCM_NUMBER"`

        if [[ -z "$DCM_PIDS" ]]; then
            if [[ -z "$DCM_NUMBER" ]]; then
                echo "Successfully killed all DCM PIDs using signal \"$SIGNAL\"."
            else
                echo "Successfully killed DCM instance \"$DCM_NUMBER\" PIDs using signal \"$SIGNAL\"."
            fi
        else
            if [[ -z "$DCM_NUMBER" ]]; then
                echo "Failed to kill all DCM PIDs using signal \"$SIGNAL\"."
            else
                echo "Failed to kill DCM instance \"$DCM_NUMBER\" PIDs using signal \"$SIGNAL\"."
            fi

            if [[ "$SIGNAL" != "-9" ]]; then
                echo "$USAGE"
                echo "Try using signal \"-9\" to kill DCM PIDs."  
            fi 
        fi
    else
        if [[ -z "$DCM_NUMBER" ]]; then
            echo "No DCM PIDs currently running."
        else
            echo "No DCM instance \"$DCM_NUMBER\" PIDs currently running."
        fi
    fi
}

function ls_dcm_pids()
{
    local DCM_NUMBER="$1"

    ps_dcm "$DCM_NUMBER" | sed "s/^$USER[ ]*\([0-9]*\).*/\1/"
}

function ps_dcm()
{
    local DCM_NUMBER="$1"

    if [[ -z "$DCM_NUMBER" ]]; then
        ps -ef | grep $USER | grep -v gcc | grep -v g++ | grep -e Dcmd -e DcmClient -e postgres -e pg_ctl -e confd -e TestApp | grep -v grep
    else
        if [[ ! "$DCM_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "Invalid DCM number \"$DCM_NUMBER\" !"
            return 1
        fi

        local MGMTPORT=`expr 9109 + $DCM_NUMBER`
        local DBPORT=`expr 9012 + $DCM_NUMBER`
        local CONFDOFFSET=`expr 100 \* $DCM_NUMBER`
        local CONFDPORT=`expr 4565 + $CONFDOFFSET`

        local PROCESS_LIST=`ps -ef | grep $USER | grep -v gcc | grep -v g++ | grep -v make | grep -e Dcmd -e Ccmd -e Mcdsd -e DcmClient -e postgres -e pg_ctl -e TestApp | grep -e "\b$DCM_NUMBER\b" -e "\b$MGMTPORT\b" -e "\b$DBPORT\b" | grep -v grep`

        local PSEUDO_TERMINAL=`echo $PROCESS_LIST | awk '{print $6}'`

        local CONFD_NETSTAT_PID=`netstat -tlnp 2>/dev/null | grep confd | grep "$CONFDPORT" | awk '{print $7}' | awk -F '/' '{print $1}' | uniq`
        local CONFD_PROCESS_LIST=""

        if [[ -n "$CONFD_NETSTAT_PID" && -n "$PSEUDO_TERMINAL" ]]; then
            CONFD_PROCESS_LIST=`ps -ef | grep $USER | grep -v gcc | grep -v g++ | grep -v make | grep -e confd | grep -v Dcmd | grep -e "$CONFD_NETSTAT_PID" -e "\b$PSEUDO_TERMINAL\b" | grep -v grep`
        elif [[ -n "$CONFD_NETSTAT_PID" && -z "$PSEUDO_TERMINAL" ]]; then
            CONFD_PROCESS_LIST=`ps -ef | grep $USER | grep -v gcc | grep -v g++ | grep -v make | grep -e confd | grep -v Dcmd | grep -e "$CONFD_NETSTAT_PID" | grep -v grep`
        elif [[ -z "$CONFD_NETSTAT_PID" && -n "$PSEUDO_TERMINAL" ]]; then
            CONFD_PROCESS_LIST=`ps -ef | grep $USER | grep -v gcc | grep -v g++ | grep -v make | grep -e confd | grep -v Dcmd | grep -e "\b$PSEUDO_TERMINAL\b" | grep -v grep`
        fi

        if [[ -n "$PROCESS_LIST" && -n "$CONFD_PROCESS_LIST" ]]; then
            echo -e "$PROCESS_LIST\n$CONFD_PROCESS_LIST"
        elif [[ -n "$PROCESS_LIST" && -z "$CONFD_PROCESS_LIST" ]]; then
            echo -e "$PROCESS_LIST"
        elif [[ -z "$PROCESS_LIST" && -n "$CONFD_PROCESS_LIST" ]]; then
            echo -e "$CONFD_PROCESS_LIST"
        fi 
    fi
}

# Function: dcm_simulator_cluster_script_generator
# Description: This will generate a script file which can be loaded in the simulator to start cluster formation.
function dcm_simulator_cluster_script_generator()
{
    local USAGE="Usage: dcm_simulator_cluster_script_generator [Simulator host IP address] <Starting DomainId: 1-254> <Principal DomainId: 1-254> <List of DCM_NUMBER instances>"

    if [[ $# -lt 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local HOST_IP_ADDRESS=""

    if [[ "$1" =~ ^[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+$ ]]; then
        HOST_IP_ADDRESS="$1"
        shift
    fi

    if [[ -z "$HOST_IP_ADDRESS" ]]; then
        # Use the current host's IP address
        HOST_IP_ADDRESS=`nslookup $HOSTNAME | sed -n 's/Address: //p'`
    fi

    local STARTING_DOMAIN_ID="$1"
    shift

    if [[ -z "$STARTING_DOMAIN_ID" ]]; then
        # Default to 1
        STARTING_DOMAIN_ID=1
    fi

    local PRINCIPAL_DOMAIN_ID="$1"
    shift

    if [[ -z "$PRINCIPAL_DOMAIN_ID" ]]; then
        # Default to the starting domain
        PRINCIPAL_DOMAIN_ID="$STARTING_DOMAIN_ID"
    fi

    local DCM_NUMBERS=( $@ )
    local DCM_FILE_PREFIX="dsim"

    if [[ $STARTING_DOMAIN_ID -le 0 || $STARTING_DOMAIN_ID -ge 255 ]]; then
        echo $USAGE
        echo -e "Error: Starting Domain Id \"$STARTING_DOMAIN_ID\" is invalid!\n"
        return 2
    fi

    local MAX_DOMAIN_INDEX=`expr $STARTING_DOMAIN_ID + ${#DCM_NUMBERS[@]}`

    if [[ $MAX_DOMAIN_INDEX -ge 255 ]]; then
        echo $USAGE
        echo -e "Error: Starting Domain Id \"$STARTING_DOMAIN_ID\" is invalid for the number of DCM instances given!\n"
        return 3
    fi

    # Display input variables

    echo -e "HOST_IP_ADDRESS:\t$HOST_IP_ADDRESS"
    echo -e "STARTING_DOMAIN_ID:\t$STARTING_DOMAIN_ID"
    echo -e "PRINCIPAL_DOMAIN_ID:\t$PRINCIPAL_DOMAIN_ID"
    echo -e "DCM_NUMBERS:\t\t${DCM_NUMBERS[@]}"

    # Create new script files
    
    echo -e "\n[Generating DCM simulator cluster script files ...]"

    for i in "${DCM_NUMBERS[@]}"; do
        echo "debug" > "$DCM_FILE_PREFIX$i"
        echo -e "    - Created \"$DCM_FILE_PREFIX$i\""
    done 

    # Append domain and SCN information to script files

    local DOMAIN_ID_INDEX=$STARTING_DOMAIN_ID

    for i in "${DCM_NUMBERS[@]}"; do
        local ADD_DOMAINS_INDEX=$STARTING_DOMAIN_ID
        local SCN_INDEX=$STARTING_DOMAIN_ID

        echo "setDomainId $DOMAIN_ID_INDEX" >> "$DCM_FILE_PREFIX$i"

        for j in "${DCM_NUMBERS[@]}"; do
            local MGMTPORT=`expr 9109 + $j`
            
            echo "adddomains $ADD_DOMAINS_INDEX $HOST_IP_ADDRESS $MGMTPORT" >> "$DCM_FILE_PREFIX$i"

            ((ADD_DOMAINS_INDEX++))
        done

        echo "generateSCN 0 $DOMAIN_ID_INDEX $PRINCIPAL_DOMAIN_ID" >> "$DCM_FILE_PREFIX$i"

        for k in "${DCM_NUMBERS[@]}"; do
            if [[ $SCN_INDEX -ne $DOMAIN_ID_INDEX ]]; then
                echo "generateSCN 3 $SCN_INDEX $PRINCIPAL_DOMAIN_ID" >> "$DCM_FILE_PREFIX$i"
                echo "generateSCN 1 $SCN_INDEX $PRINCIPAL_DOMAIN_ID" >> "$DCM_FILE_PREFIX$i"
            fi

            ((SCN_INDEX++))
        done

        ((DOMAIN_ID_INDEX++)) 
    done
}

function clear_session_logs()
{
    local SESSION_LOGS_DIR="$HOME/sessionlogs"
    local SESSION_LOGS_FILTER=""
    local FILTER_INPUT=$1

    if [ -n "$FILTER_INPUT" ]; then
        SESSION_LOGS_FILTER="$SESSION_LOGS_DIR/$FILTER_INPUT"
    else
        SESSION_LOGS_FILTER="$SESSION_LOGS_DIR"
    fi
   

    echo "Session Log Filter: $SESSION_LOGS_FILTER"

    for i in `ls -1 $SESSION_LOGS_FILTER`; do
        echo "Clearing out file \"$SESSION_LOGS_DIR/$i\" ..."
        cat /dev/null > "$SESSION_LOGS_DIR/$i"
    done
}

# Function: terminal_laucher
# Description: This will launch a preset multi-tabbed gnome terminal.  When chassis or switch is specified with a label then all terminal session output
#              Is logged to an appropriate labeled file under $HOME/sessionlogs.
function terminal_launcher()
{
    local USAGE="Usage: terminal_launcher < <dev|code|sim> <server host name to SSH into> | <chassis|switch> <Label for the device> >"

    if [[ $# -lt 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi


    local TERMINAL="mate-terminal"
    local TERM_CLASS=$2
    local PARAM=$3

    # Create a session log directory
    if [[ "$TERM_CLASS" == "switch" || "$TERM_CLASS" == "chassis" && -n "$PARAM" ]]; then
        if [ ! -d $HOME/sessionlogs ]; then
            mkdir $HOME/sessionlogs
        fi
    fi


    if [ "$TERM_CLASS" == "code" ]; then
        if [ -z "$PARAM" ]; then
            PARAM=$BUILD_HOST
        fi

        $TERMINAL --geometry=$FULL_TERMINAL_GEOMETRY \
            --tab --title=editor1 --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.0; done"\' --active \
            --tab --title=editor2 --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.1; done"\' \
            --tab --title=editor3 --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.2; done"\' \
            --tab --title=build   --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.3; done"\'
    elif [ "$TERM_CLASS" == "sim" ]; then 
        if [ -z "$PARAM" ]; then
            PARAM=$BUILD_HOST
        fi

        $TERMINAL --geometry=$FULL_TERMINAL_GEOMETRY \
            --tab --title=dcm1      --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.0; done"\' --active \
            --tab --title=dcm2      --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.1; done"\' \
            --tab --title=dcm3      --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.2; done"\' \
            --tab --title=dcmclient --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.3; done"\' \
            --tab --title=confdcli  --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.4; done"\' \
            --tab --title=misc_gdb  --command "bash -c 'while [ \"no\" == `xauth info | sed -n 's/File locked:[ ]*\([a-z]*\)/\1/p'` ]; do ssh -Yt $PARAM; sleep 0.6; done"\' 
    elif [ "$TERM_CLASS" == "dev" ]; then
        terminal_launcher $TERMINAL code $PARAM&
        sleep 2
        terminal_launcher $TERMINAL sim $PARAM

    elif [ "$TERM_CLASS" == "switch" ]; then
        if [ -z "$PARAM" ]; then
            $TERMINAL --geometry=$SWITCH_TERMINAL_GEOMETRY \
                --tab --active -t Console \
                --tab -t Telnet \
                --tab -t Telnet \
                --tab -t Telnet
        else
            $TERMINAL --geometry=$SWITCH_TERMINAL_GEOMETRY \
                --tab --active -t "$PARAM Console" -e "script -afq $HOME/sessionlogs/$PARAM.Console.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM Telnet1" -e "script -afq $HOME/sessionlogs/$PARAM.Telnet1.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM Telnet2" -e "script -afq $HOME/sessionlogs/$PARAM.Telnet2.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM Telnet3" -e "script -afq $HOME/sessionlogs/$PARAM.Telnet3.`date +%Y%m%d.%H%M%S`.txt"
        fi
    elif [ "$TERM_CLASS" == "chassis" ]; then
        if [ -z "$PARAM" ]; then
            $TERMINAL --geometry=$CHASSIS_TERMINAL_GEOMETRY \
                --tab --active -t "MM1 Console" \
                --tab -t "MM2 Console" \
                --tab -t "LC# Console" \
                --tab -t "LC# Console" \
                --tab -t Telnet \
                --tab -t Telnet \
                --tab -t Telnet
        else
            $TERMINAL --geometry=$CHASSIS_TERMINAL_GEOMETRY \
                --tab --active -t "$PARAM MM1 Console" -e "script -afq $HOME/sessionlogs/$PARAM.MM1.Console.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM MM2 Console" -e "script -afq $HOME/sessionlogs/$PARAM.MM2.Console.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM LC# Console" -e "script -afq $HOME/sessionlogs/$PARAM.LC1.Console.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM LC# Console" -e "script -afq $HOME/sessionlogs/$PARAM.LC2.Console.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM Telnet1" -e "script -afq $HOME/sessionlogs/$PARAM.Telnet1.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM Telnet2" -e "script -afq $HOME/sessionlogs/$PARAM.Telnet2.`date +%Y%m%d.%H%M%S`.txt" \
                --tab -t "$PARAM Telnet3" -e "script -afq $HOME/sessionlogs/$PARAM.Telnet3.`date +%Y%m%d.%H%M%S`.txt"
        fi
    elif [ "$TERM_CLASS" == "full" ]; then
        $TERMINAL --geometry=$FULL_TERMINAL_GEOMETRY
    else
        $TERMINAL
    fi
}

# Function: cleartool_diff_review
# Description: This will do a clearcase diff review of current checkouts or from a file containing clearcase files for review.
#              "diff" [fastest diff option]: Each clearcase element is scanned for stats and correct versioning is determined so 
#                                            a proper diff can be done.  Either by latest merged version or predecessor version.
#              "xlsvtree"  [slowest option]: xlsvtree is launched which will take time for elements that have many versions
#                                            existing in clearcase.
#              "scan"      [testing option]: The scan option will only show clearcase stats for each element but will not launch
#                                            any diff or xlsvtree for code review.
function cleartool_diff_review()
{
    local USAGE="Usage: cleartool_diff_review <diff | xlsvtree | scan> [filename containing list of files for review]"
    local OPTION=$1
    local REVIEW_FILE=$2
    local FILENAME_LIST=$3

    if [[ $# -lt 1 || "$OPTION" != "diff" && "$OPTION" != "xlsvtree" && "$OPTION" != "scan" || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local COUNT=0
    local VIEW_NAME=`get_current_view`
    local BRANCH_NAME=`get_branch_name`
    local REVIEW_FILE_LIST=()

    echo "[Current View : $VIEW_NAME]"
    echo "[Branch Name : $BRANCH_NAME]"

    if [[ -n "$REVIEW_FILE" && "$REVIEW_FILE" != "file" ]]; then
        if [[ -f $REVIEW_FILE ]]; then
            REVIEW_FILE_LIST=($REVIEW_FILE)
        else
            echo "\"$REVIEW_FILE\" does not exist or is not a file!"
            return 2
        fi
    elif [[ -n $FILENAME_LIST ]]; then
        if [[ -f $FILENAME_LIST ]]; then 
            if [[ -s $FILENAME_LIST ]]; then
                echo "[Retrieving checkout file list from \"$FILENAME_LIST\" for review ...]"
                REVIEW_FILE_LIST=$(<$FILENAME_LIST)
            else
                echo "\"$FILENAME_LIST\" is empty!"
                return 3
            fi
        else
            echo "\"$FILENAME_LIST\" does not exist or is not a file!"
            return 2
        fi
    else
        echo "[Retrieving checkouts for review ...]"
        REVIEW_FILE_LIST=(`$CLEARTOOL lsco -avobs -cview -s`)
    fi

    for i in ${REVIEW_FILE_LIST[@]}; do
        ((COUNT++))

        local DESCRIPTION=`$CLEARTOOL describe $i`
        local ELEMENT_TYPE=`echo $DESCRIPTION | sed -n 's/.*element type: \(\w\+\).*/\1/p'`
        local MERGE=`echo $DESCRIPTION | sed -n 's/.*Merge <- \(\S\+\).*/\1/p' | tail -1`
        local PREDECESSOR_VERSION=`echo $DESCRIPTION | sed -n 's/.*predecessor version: \(\S\+\).*/\1/p' | tail -1`
        local APPROVAL=`echo $DESCRIPTION | sed -n 's/.*Approved = \"\(\S\+\)\".*/\1/p'`
        local APPROVED_BY=`echo $DESCRIPTION | sed -n 's/.*ApprovedBY = \"\(\S\+\)\".*/\1/p'`
        local FINDMERGE=""
        local FINDMERGE_VERSION=""
        local MERGE_VERSION=""
        local DIFF_OPTION=""

        if [[ "$ELEMENT_TYPE" == "directory" ]]; then
            FINDMERGE=`$CLEARTOOL findmerge $i -directory -flatest -print -log /dev/null 2>/dev/null`
        else
            FINDMERGE=`$CLEARTOOL findmerge $i -flatest -print -log /dev/null 2>/dev/null`
        fi

        # Determine merged version or predecessor

        if [[ -n "$MERGE" ]]; then
            MERGE_VERSION=`echo $MERGE | awk -F '@@' '{print $2}'`

            local MERGE_VERSION_BRANCH=`echo $MERGE_VERSION | sed -n 's/^.*\/\([a-zA-Z0-9_.]\+\)\/[0-9]\+$/\1/p'`

            if [[ "$MERGE_VERSION_BRANCH" == "$BRANCH_NAME" ]]; then
                # Compare current with merged version if merge source originated from the same branch.

                DIFF_OPTION="$MERGE"
            else
                # Compare current with predecessor of same branch if merge source originated from a different branch.

                DIFF_OPTION="-pred"
            fi
        else
            DIFF_OPTION="-pred"
        fi

        # Display element stats

        echo "[Review Element : $COUNT]"
        echo -e "  - Element Name\t\t: $i"
        echo -e "  - Element Type\t\t: $ELEMENT_TYPE"

        if [[ -n "$MERGE_VERSION" ]]; then
            echo -e "  - Merged version\t\t: $MERGE_VERSION"
        else
            echo -e "  - Predecessor version\t\t: $PREDECESSOR_VERSION"
        fi

        if [[ "$DIFF_OPTION" == "-pred" ]]; then
            echo -e "  - Diff source version\t\t: @@$PREDECESSOR_VERSION"
        else 
            echo -e "  - Diff source version\t\t: @@$MERGE_VERSION"
        fi

        # Check if element requires a merge to latest

        if [[ -n "$FINDMERGE" ]]; then
            FINDMERGE_VERSION=`echo $FINDMERGE | sed -n 's/.*from \(.*\) base.*/\1/p'`
            echo -e "  * Requires merge to latest\t: $FINDMERGE_VERSION"
        fi

        # Check if element is checked out under the branch

        if [[ ! "$MERGE_VERSION" =~ "$BRANCH_NAME" && ! "$PREDECESSOR_VERSION" =~ "$BRANCH_NAME" ]]; then
            echo -e "  ! Element is not checked out in branch : $BRANCH_NAME"
        fi

        # Check for element approval

        if [[ "$APPROVAL" == "TRUE" ]]; then
            echo -e "  + Approved By\t\t\t: $APPROVED_BY"
        fi

        # Do appropriate diff option

        if [[ "$OPTION" == "diff" ]]; then
            $CLEARTOOL diff -g "$DIFF_OPTION" "$i" > /dev/null 2>&1
        elif [[ "$OPTION" == "xlsvtree" ]]; then
            xlsvtree $i
        elif [[ "$OPTION" == "scan" ]]; then
            $CLEARTOOL diff -serial_format "$DIFF_OPTION" "$i" > /dev/null 2>&1

            local DIFF_RC=$?

            if [[ $DIFF_RC -eq 0 ]]; then
                echo -e "  ! No difference found\t\t: Diff source version and CHECKEDOUT version are identical.  Please un-checkout this element."
            fi
        fi
    done
}

function is_file_in_branch()
{
    local BRANCH_NAME=`get_branch_name`
    local CC_DESCRIPTION=`$CLEARTOOL describe -short "$1"`

    if [[ "$CC_DESCRIPTION" =~ "$BRANCH_NAME" ]]; then
        echo "true"
    else
        echo "false"
    fi
}

function cleartool_make_dir()
{
    local BUILD_TIME_STAMP=`get_build_time_stamp raw`

    if [ -z $BUILD_TIME_STAMP ]; then
        $CLEARTOOL mkdir -nc "$@"
    else
        echo "Creating directory under LATEST and reverting back to current build timestamp: $BUILD_TIME_STAMP"
        refresh_view -edit; $CLEARTOOL mkdir -nc "$@"; refresh_view -build $BUILD_TIME_STAMP
    fi
}

function cleartool_make_element()
{
    local BUILD_TIME_STAMP=`get_build_time_stamp raw`
            
    if [ -z $BUILD_TIME_STAMP ]; then
        $CLEARTOOL mkelem -nc "$@"
    else
        echo "Creating elements under LATEST and reverting back to current build timestamp: $BUILD_TIME_STAMP"
        refresh_view -edit; $CLEARTOOL mkelem -nc "$@"; refresh_view -build $BUILD_TIME_STAMP
    fi
}

# Function: cleartool_checkout
# Description: This clearcase checkout will determine the build's timestamp from the config spec and checkout the file.
#              If the file or directory has never been checked out in the branch, then the config spec will automatically
#              be set to the latest, file or directory will be checked out, then the time stamp will be reverted back.
function cleartool_checkout()
{
    local BUILD_TIME_STAMP=`get_build_time_stamp raw`

    for i in "$@"; do
        local IS_FILE_IN_BRANCH=`is_file_in_branch "$i"`
        
        if [ -z $BUILD_TIME_STAMP ]; then
            $CLEARTOOL co -nc "$i"
        elif [ "true" == "$IS_FILE_IN_BRANCH" ]; then
            echo "Checking out under current build timestamp: $BUILD_TIME_STAMP"
            $CLEARTOOL co -nc -ver "$i"
        else
            echo "Checking out under LATEST and reverting back to current build timestamp: $BUILD_TIME_STAMP"
            refresh_view -edit; $CLEARTOOL co -nc "$i"; refresh_view -build $BUILD_TIME_STAMP
        fi
    done
}

function get_current_build_swbds()
{
    local BRANCH_NAME=`get_branch_name`
    local BUILD_DIR_PATH=`get_src_path "build"`
    local SWBD_PLATFORMS=`ls -1 /$BUILD_DIR_PATH | sed -n '/^swbd\d*/p'`

    if [ -z "$BRANCH_NAME" ]; then
        echo "The branch name could not be determined.  Is a view set correctly?"
        exit 1
    fi

    echo $SWBD_PLATFORMS
}

function get_new_clearcase_elements()
{
    local BRANCH_NAME=`get_branch_name`

    if [ -z "$BRANCH_NAME" ]; then
        echo "The branch name could not be determined.  Is a view set correctly?"
        exit 1
    fi

    for i in `ctlsco`; do
        version=`$CLEARTOOL describe $i | sed -n 's/.*predecessor version: \(.*\)/\1/p'`
        
        if [[ "$version" == "/main/$BRANCH_NAME/0" ]]; then
            echo $i
        fi
    done
}

function strip_filenames_and_get_unique_directories()
{
    local FILE_LIST="$@"

    for file in $FILE_LIST; do
        echo $file | sed -n 's/\(^.*\)\/.*$/\1/p'
    done | sort | uniq
}

# Function: symlink_new_clearcase_elements
# Description: This will scan all clearcase checkouts and see if there are any new elements created in the branch.
#              It will also detect which SWBD platforms are currently built and create new symlinks for new elements
#              per SWBD.
function symlink_new_clearcase_elements()
{
    echo "[Finding new clearcase elements for symlinking ...]"

    local ORIGINAL_DIR=`pwd`
    local SWBD_PLATFORMS=`get_current_build_swbds`
    local NEW_CLEARCASE_ELEMENTS=`get_new_clearcase_elements`
    local UNIQUE_DIRECTORIES=`strip_filenames_and_get_unique_directories $NEW_CLEARCASE_ELEMENTS`
    
    echo "[Performing symlinking of new clearcase elements ...]"

    for swbd in $SWBD_PLATFORMS; do
        echo "[$swbd]"

        for dir in $UNIQUE_DIRECTORIES; do
            sym_dir=`echo $dir | sed "s/springboard/springboard\/build\/$swbd/"`

            echo -e "\t- Symlinking $dir ..."
            cd $sym_dir && rm -rf * && lndir $dir > /dev/null 2>&1
        done
    done

    cd $ORIGINAL_DIR

    return 0
}

# Function: symlink_clearcase_elements
# Description: This will symlink wave and dcm source for all current SWBDs.
function symlink_clearcase_elements()
{
    local USAGE="symlink_clearcase_elements <wave | dcm | all>"
    local SYMLINK_TYPE="$1"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    if [[ "$SYMLINK_TYPE" != "wave" && "$SYMLINK_TYPE" != "dcm" && "$SYMLINK_TYPE" != "all" ]]; then
        echo "$USAGE"
        echo -e "Error: Invalid argument \"$SYMLINK_TYPE\" given!\n"
        return 2
    fi

    local ORIGINAL_DIR=`pwd`
    local SWBD_PLATFORMS=`get_current_build_swbds`
    local DIRECTORIES=""
    local SRC_PATH=""

    SRC_PATH=`get_src_path "wave"`

    local WAVE_SOURCE_DIR="/$SRC_PATH"

    SRC_PATH=`get_src_path "dcm"`

    local DCM_SOURCE_DIR="/$SRC_PATH"

    if [[ "$SYMLINK_TYPE" == "all" ]]; then
        DIRECTORIES=( "$WAVE_SOURCE_DIR" "$DCM_SOURCE_DIR" )
    elif [[ "$SYMLINK_TYPE" == "wave" ]]; then
        DIRECTORIES=( "$WAVE_SOURCE_DIR" )
    elif [[ "$SYMLINK_TYPE" == "dcm" ]]; then
        DIRECTORIES=( "$DCM_SOURCE_DIR" )
    fi

    echo "[Performing symlinking of clearcase elements for $SYMLINK_TYPE ...]"

    for swbd in $SWBD_PLATFORMS; do
        echo "[$swbd]"

        for dir in "${DIRECTORIES[@]}"; do
            sym_dir=`echo $dir | sed "s/springboard/springboard\/build\/$swbd/"`

            echo -e "\t- Symlinking $dir ..."
            cd $sym_dir && rm -rf * && lndir $dir > /dev/null 2>&1
        done
    done

    cd $ORIGINAL_DIR

    return 0
}

function vobs_user_quota()
{
    /corp/global/tools/bin/srt_my_storage_info.pl
}

function get_postgres_version()
{
    local INTEL_ARCH=`get_intel_os_type`
    local POSTGRES_TARBALL_PATH="$BASE_SRC/fabos/bccb/dsf/Wave/WaveDependencies/Linux/$INTEL_ARCH/postgresql"
    local POSTGRES_VERSION="9.1.1"

    if [ -d "$POSTGRES_TARBALL_PATH" ]; then
        POSTGRES_VERSION=`ls -1t $POSTGRES_TARBALL_PATH | grep tgz$ | sed -n 1p | sed 's/postgresql-\(.*\).tgz/\1/'`
    fi

    echo "$POSTGRES_VERSION"
}

# Function: efarestoredb
# Description: The function will start a postgres server instance and restore a Postgres Database dump file in ascii.
#              Psql will automatically be launched after the database restore and postgres server instance will be cleaned up after user
#              quits psql. 
function efarestoredb()
{
    local USAGE="Usage: efarestoredb <ascii pg_dump file containing schema and data> [postgres server portnumber (Default: 5432)]"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local DB_USER_NAME=("asset" "fabric" "tenant" "vcenter" "hyperv" "openstack")
    local POSTGRES_PORT_OPTION
    local POSTGRES_SERVER_NAME="EFARestoredDB"
    local POSTGRES_LOGFILE_NAME="pgctl_log"
    local EFA_CREATE_ROLES=""

    for user in ${DB_USER_NAME[@]}; do
        EFA_CREATE_ROLES=$EFA_CREATE_ROLES"create role $user;"
    done

    local POSTGRES_DUMP_FILE=$1
    local POSTGRES_PORT=$2

    if [ -z "$POSTGRES_PORT" ]; then
        POSTGRES_PORT=5432
    fi

    POSTGRES_SERVER_NAME="$POSTGRES_SERVER_NAME.$POSTGRES_PORT"
    POSTGRES_PORT_OPTION="-p $POSTGRES_PORT"
    POSTGRES_LOGFILE_NAME="$POSTGRES_SERVER_NAME.pgctl_log"

    # Display script variables
    echo "POSTGRES_SERVER_NAME  = $POSTGRES_SERVER_NAME"
    echo "POSTGRES_PORT         = $POSTGRES_PORT"
    echo "POSTGRES_LOGFILE_NAME = $POSTGRES_LOGFILE_NAME"
    echo ""

    # Verify postgres server port is free
    local POSTGRES_PORT_IN_USE=`ps -ef | grep "$USER" | grep "$POSTGRES_PORT"`

    if [[ $POSTGRES_PORT_IN_USE =~ "$POSTGRES_SERVER_NAME" ]]; then
        echo "The requested postgres server port \"$POSTGRES_PORT\" is already in use.  Please try another port number."
        echo $USAGE
        return 1
    fi

    rm -rf $POSTGRES_SERVER_NAME

    echo -e "\n[Initializing Postgres Database]"
    initdb -D $POSTGRES_SERVER_NAME

    echo -e "\n[Starting Postgres Database Server]"
    pg_ctl start -w -D $POSTGRES_SERVER_NAME -l $POSTGRES_LOGFILE_NAME -o "$POSTGRES_PORT_OPTION"

    echo -e "\n[Creating Database Instance]"
    createdb --echo --template=template0 $POSTGRES_PORT_OPTION $POSTGRES_SERVER_NAME

    psql $POSTGRES_PORT_OPTION -d $POSTGRES_SERVER_NAME -c "$EFA_CREATE_ROLES"

    echo -e "\n[Restoring Database Ascii Dump]"
    pg_restore $POSTGRES_PORT_OPTION -d $POSTGRES_SERVER_NAME $POSTGRES_DUMP_FILE

    echo -e "\n[Launching PostgresSQL Client]"
    psql --pset=pager=off $POSTGRES_PORT_OPTION -d $POSTGRES_SERVER_NAME

    echo -e "\n[Stopping Postgres Database Server]"
    pg_ctl -w -D $POSTGRES_SERVER_NAME -l $POSTGRES_LOGFILE_NAME stop
}

efarestoremysqldb()
{
    local USAGE="Usage: efarestoremysqldb <db dump file> [GoInventory source dir]"

    if  [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi
    
    local MYSQL_DUMP_FILE="$(readlink -f $1)"
    local MYSQL_SETUP_DIR=""

    if [[ ! -f "$MYSQL_DUMP_FILE" ]]; then
        echo "$USAGE"
        echo "$MYSQL_DUMP_FILE cannot be found or does not exist."
        return 1
    fi

    if [[ -n "$2" ]]; then
        MYSQL_SETUP_DIR="$(readlink -f $2)"
    fi
    
    if [[ -z "$MYSQL_SETUP_DIR" ]]; then
        MYSQL_SETUP_DIR="$(echo $GOPATH | tr ":" "\n" | grep GoInventory)"
    fi

    echo "MYSQL_DUMP_FILE: $MYSQL_DUMP_FILE"
    echo "MYSQL_SETUP_DIR: $MYSQL_SETUP_DIR"

    if [[ -z "$MYSQL_SETUP_DIR" ]]; then
        echo "$USAGE"
        echo "Cannot find GoInventory source dir check input or GOPATH ENV is set."
        return 1
    fi

    declare -A dbMap

    dbMap[inventory]="dcapp_asset"
    dbMap[fabric]="dcapp_fabric"
    dbMap[ts]="dcapp_tenant"
    dbMap[notification]="dcapp_notification"
    dbMap[vcenter]="dcapp_vcenter"
    dbMap[hyperv]="dcapp_hyperv"
    dbMap[openstack]="efa_openstack"
    dbMap[rbac]="dcapp_rbac"
    dbMap[auth]="dcapp_auth"
    dbMap[system]="dcapp_system"
    dbMap[faultmanager]="dcapp_faultmanager"
    dbMap[policy]="dcapp_policy"

    local MYSQL_DUMP_FILE_BASENAME="$(basename $MYSQL_DUMP_FILE)"
    local MYSQL_DUMP_FILE_PREFIX="$(echo $MYSQL_DUMP_FILE_BASENAME | awk -F '_' '{print $1}')"
    local MYSQL_DB_NAME="${dbMap[${MYSQL_DUMP_FILE_PREFIX}]}"

    #echo "MYSQL_DUMP_FILE_BASENAME: $MYSQL_DUMP_FILE_BASENAME"
    #echo "MYSQL_DUMP_FILE_PREFIX: $MYSQL_DUMP_FILE_PREFIX"
    echo "MYSQL_DB_NAME: $MYSQL_DB_NAME"

    docker stop mysql-db-restore || true && docker rm mysql-db-restore || true
    docker run -d -p 3306-3336:3306 --name mysql-db-restore -e MYSQL_ROOT_PASSWORD=password -d mariadb:10.4
    docker exec mysql-db-restore mkdir efa
    docker cp "$MYSQL_SETUP_DIR/scripts" mysql-db-restore:efa/scripts
    docker cp "$MYSQL_SETUP_DIR/etc" mysql-db-restore:efa/etc
    docker cp "$MYSQL_DUMP_FILE" mysql-db-restore:efa
    docker exec mysql-db-restore apt-get update >/dev/null || true
    docker exec mysql-db-restore apt-get install -y sudo >/dev/null
    sleep 20
    docker exec mysql-db-restore bash -c "cd efa/scripts && bash dcapp_mysql_setup.sh" >/dev/null
    docker exec mysql-db-restore bash -c "cd efa && mysql -uroot -ppassword --force $MYSQL_DB_NAME < $MYSQL_DUMP_FILE_BASENAME" >/dev/null
    docker exec -it mysql-db-restore bash -c "mysql -uroot -ppassword -c $MYSQL_DB_NAME"
}

# Function: nvorestoredb
# Description: The function will start a postgres server instance and restore a Postgres Database dump file in ascii.
#              Psql will automatically be launched after the database restore and postgres server instance will be cleaned up after user
#              quits psql. 
function nvorestoredb()
{
    local USAGE="Usage: nvorestoredb <pg_dump sql file containing schema and data> [postgres server portnumber (Default: 5432)]"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local POSTGRES_CONTAINER_NAME="postgres-db-restore"
    local POSTGRES_DEFAULT_PORT=5432
    local POSTGRES_NVO_DB_NAME="nvo_db"

    local POSTGRES_DUMP_FILE=$1
    local POSTGRES_PORT=$2

    local POSTGRES_MAX_PORT=5439

    if [ -z "$POSTGRES_PORT" ]; then
        # Use the next available port up until POSTGRES_MAX_PORT instead of default to not overlap with the dev env's postgres db.
        POSTGRES_PORT=5433
    fi

    # Display script variables
    echo "POSTGRES_DUMP_FILE  = ${POSTGRES_DUMP_FILE}"
    echo ""

    docker rm -f ${POSTGRES_CONTAINER_NAME} || true
    docker run -d -p ${POSTGRES_PORT}-${POSTGRES_MAX_PORT}:${POSTGRES_DEFAULT_PORT} --name ${POSTGRES_CONTAINER_NAME} -e POSTGRES_PASSWORD=password -d postgres:15.4
    docker exec ${POSTGRES_CONTAINER_NAME} mkdir nvo
    docker cp ${POSTGRES_DUMP_FILE} ${POSTGRES_CONTAINER_NAME}:nvo
    sleep 5
    docker exec ${POSTGRES_CONTAINER_NAME} bash -c "dropdb -U postgres --if-exists ${POSTGRES_NVO_DB_NAME}" 2>/dev/null
    docker exec ${POSTGRES_CONTAINER_NAME} bash -c "createdb -U postgres -T template0 ${POSTGRES_NVO_DB_NAME}" >/dev/null
    docker exec ${POSTGRES_CONTAINER_NAME} bash -c "psql -U postgres -c 'CREATE ROLE rdsadmin'" >/dev/null
    docker exec ${POSTGRES_CONTAINER_NAME} bash -c "cd nvo && psql -U postgres -f ${POSTGRES_DUMP_FILE} -d ${POSTGRES_NVO_DB_NAME}"
    docker exec -it ${POSTGRES_CONTAINER_NAME} bash -c "psql -U postgres -d ${POSTGRES_NVO_DB_NAME}"
}

# Function: restoredb
# Description: The function will start a postgres server instance and restore a Postgres Database dump file in ascii or non-ascii format.
#              Psql will automatically be launched after the database restore and postgres server instance will be cleaned up after user
#              quits psql. 
function restoredb()
{
    local USAGE="Usage: restoredb <ascii pg_dump file containing schema and data> [data-only pg_dump file for restore using first parameter's schema] [postgres server portnumber (Default: 5432)]"
    local INTEL_ARCH=`get_intel_os_type`

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local POSTGRES_TARBALL_PATH="$BASE_SRC/fabos/bccb/dsf/Wave/WaveDependencies/Linux/$INTEL_ARCH/postgresql"
    local POSTGRES_TARBALL=`ls -1t $POSTGRES_TARBALL_PATH | grep tgz$ | sed -n 1p`
    local POSTGRES_INTEL_ARCH_EXTRACTED_PATH="$BASE_SRC/build/target26/postgresql/$INTEL_ARCH"
    local POSTGRES_VERSION=`get_postgres_version`
    local POSTGRES_EXTRACTED_BASE_PATH="$POSTGRES_INTEL_ARCH_EXTRACTED_PATH/$POSTGRES_VERSION"

    local ORIGINAL_DIR=`pwd`
    local CURRENT_VIEW=`get_current_view`    
    local POSTGRES_PORT_OPTION
    local POSTGRES_SSHOW_ALLDBDUMP="false"
    local POSTGRES_SERVER_NAME="RestoredWaveDB"
    local POSTGRES_LOGFILE_NAME="pgctl_log"

    local POSTGRES_DUMP_FILE=$1
    local PARAMETER2_FILE_TEST=`file -b $2`
    local POSTGRES_PORT=$3
    local POSTGRES_DATA_ONLY_BACKUP=""
    local POSTGRES_DATA_ONLY_EMPTY_COMMAND="DO \
\$func\$ \
BEGIN \
   EXECUTE ( \
      SELECT 'TRUNCATE TABLE ' \
             || string_agg(concat(quote_ident(t.schemaname), '.', quote_ident(t.tablename)), ', ') \
             || ' CASCADE' \
      FROM   pg_tables t \
      WHERE  t.schemaname = 'wavestart' \
   ); \
   EXECUTE ( \
      SELECT 'TRUNCATE TABLE ' \
             || string_agg(concat(quote_ident(t.schemaname), '.', quote_ident(t.tablename)), ', ') \
             || ' CASCADE' \
      FROM   pg_tables t \
      WHERE  t.schemaname = 'wavecurrent' \
   ); \
END \
\$func\$; \
"

    if [[ "$PARAMETER2_FILE_TEST" == "data" ]]; then
        POSTGRES_DATA_ONLY_BACKUP=$ORIGINAL_DIR/$2
    else
        POSTGRES_PORT=$2
    fi

    if [ -z "$POSTGRES_PORT" ]; then
        POSTGRES_PORT=5432
    fi

    POSTGRES_DUMP_FILE_FORMAT=`file -b "$POSTGRES_DUMP_FILE"`
    POSTGRES_SERVER_NAME="$POSTGRES_SERVER_NAME.$POSTGRES_PORT"
    POSTGRES_PORT_OPTION="-p $POSTGRES_PORT"
    POSTGRES_LOGFILE_NAME="$POSTGRES_SERVER_NAME.pgctl_log"

    # Display script variables
    echo "POSTGRES_TARBALL_PATH                 = $POSTGRES_TARBALL_PATH"
    echo "POSTGRES_TARBALL                      = $POSTGRES_TARBALL"
    echo "POSTGRES_EXTRACTED_BASE_PATH          = $POSTGRES_EXTRACTED_BASE_PATH"
    echo "POSTGRES_VERSION                      = $POSTGRES_VERSION"
    echo "POSTGRES_SERVER_NAME                  = $POSTGRES_SERVER_NAME"
    echo "POSTGRES_LOGFILE_NAME                 = $POSTGRES_LOGFILE_NAME"
    echo "POSTGRES_DATA_ONLY_BACKUP             = $POSTGRES_DATA_ONLY_BACKUP"
    echo "CURRENT_VIEW                          = $CURRENT_VIEW"
    echo ""

    # Verify a clear case view is set.  We need the view to access Postgres tarball.
    if [[ ! "$CURRENT_VIEW" =~ "$USER" ]]; then
        echo "Please set a view which you have write permissions."
        return 1;
    fi
        
    # Verify postgres server port is free
    local POSTGRES_PORT_IN_USE=`ps -ef | grep "$USER" | grep "$POSTGRES_PORT"`

    if [[ $POSTGRES_PORT_IN_USE =~ "$POSTGRES_SERVER_NAME" ]]; then
        echo "The requested postgres server port \"$POSTGRES_PORT\" is already in use.  Please try another port number."
        echo $USAGE
        return 1
    fi

    # Set LD_LIBRARY_PATH for postgres libs
    echo "Prepending LD_LIBRARY_PATH with \"$POSTGRES_EXTRACTED_BASE_PATH/lib\" for postgres libs"
    export LD_LIBRARY_PATH=$POSTGRES_EXTRACTED_BASE_PATH/lib:$LD_LIBRARY_PATH

    if [[ "$POSTGRES_DUMP_FILE_FORMAT" =~ ASCII ]]; then
        echo "$POSTGRES_DUMP_FILE detected as plain text format.  File will be replayed to restore this database."
        POSTGRES_SSHOW_ALLDBDUMP="true"
    fi

    if [[ "$POSTGRES_DUMP_FILE" =~ ^[A-Za-z.] ]]; then
        POSTGRES_DUMP_FILE=$ORIGINAL_DIR/$1
    fi 

    if [[ -d "$POSTGRES_DUMP_FILE" ]]; then
        POSTGRES_DUMP_FILE_INPUT_IS_DIRECTORY="true"
    fi

    if [ ! -e "$POSTGRES_DUMP_FILE" ]; then
        echo "Postgres dump file or directory \"$POSTGRES_DUMP_FILE\" does not exist."
        return 1;
    fi

    local SRC_PATH=`get_src_path "postgres"`
        
    if [ ! -e "/$SRC_PATH" ]; then
        echo -e "\n[Extract Postgres Tarball From View]"
        mkdir -p $POSTGRES_INTEL_ARCH_EXTRACTED_PATH
        cd $POSTGRES_INTEL_ARCH_EXTRACTED_PATH
        tar -xzvf $POSTGRES_TARBALL_PATH/$POSTGRES_TARBALL
    fi

    cd /$SRC_PATH

    if [[ "$POSTGRES_DUMP_FILE_INPUT_IS_DIRECTORY" == "true" ]]; then
        ./postgres --single -D $POSTGRES_DUMP_FILE $POSTGRES_PORT_OPTION &
        sleep 3
        ./psql $POSTGRES_PORT_OPTION -d WaveDatabase -c "create role root"
        ./psql $POSTGRES_PORT_OPTION -d WaveDatabase

        kill `ps -ef | grep "$USER" | grep "$POSTGRES_DUMP_FILE" | awk '{print $2}'`; sleep 1
    else
        rm -rf $POSTGRES_SERVER_NAME

        echo -e "\n[Initializing Postgres Database Cluster]"
        ./initdb -D $POSTGRES_SERVER_NAME

        echo -e "\n[Starting Postgres Database Server]"
        ./pg_ctl start -w -D $POSTGRES_SERVER_NAME -l $POSTGRES_LOGFILE_NAME -o "$POSTGRES_PORT_OPTION"

        echo -e "\n[Creating Wave Database Instance]"
        ./createdb --echo --template=template0 $POSTGRES_PORT_OPTION WaveDatabase

        ./psql $POSTGRES_PORT_OPTION -d WaveDatabase -c "create role root"

        if [ "true" == "$POSTGRES_SSHOW_ALLDBDUMP" ]; then
            echo -e "\n[Replaying Wave Database Ascii Dump]"
            ./psql $POSTGRES_PORT_OPTION -e template1 < $POSTGRES_DUMP_FILE

            if [[ -f "$POSTGRES_DATA_ONLY_BACKUP" ]]; then
                echo -e "\n[Empty Data From Database]"
                ./psql $POSTGRES_PORT_OPTION -d WaveDatabase -c "$POSTGRES_DATA_ONLY_EMPTY_COMMAND"
                echo -e "\n[Restoring Data-Only Backup]"
                ./pg_restore $POSTGRES_PORT_OPTION -v -j 7 -d WaveDatabase $POSTGRES_DATA_ONLY_BACKUP
            fi
        else
            echo -e "\n[Restoring Wave Database]"
            ./pg_restore $POSTGRES_PORT_OPTION -v -j 7 -d WaveDatabase $POSTGRES_DUMP_FILE
        fi
    
        echo -e "\n[Launching PostgresSQL Client]"
        ./psql --pset=pager=off $POSTGRES_PORT_OPTION -d WaveDatabase

        echo -e "\n[Stopping Postgres Database Server]"
        ./pg_ctl -w -D $POSTGRES_SERVER_NAME -l $POSTGRES_LOGFILE_NAME stop
    fi

    cd $ORIGINAL_DIR
}

function mount_tech_pubs()
{
    local TECH_PUBS_DIR="/mnt/tech_pubs"
    local CIFS_SERVER="//vault13/support/tech_pubs"
    local PASS=""

    read -s "PASS?Extreme Password: "

    # Use keberos to cifs mount
    echo "${PASS}" | sudo kinit "${USER}" > /dev/null

    if [[ ! -d "${TECH_PUBS_DIR}" ]] ; then
        sudo mkdir -p ${TECH_PUBS_DIR}
    fi

    if sudo mount -t cifs -o "domain=corp.extremenetworks.com,username=badaniya,sec=krb5,noserverino" ${CIFS_SERVER} ${TECH_PUBS_DIR} ; then
        echo -e "\nMounted ${TECH_PUBS_DIR} successfully."
    fi
}

function umount_tech_pubs()
{
    sudo umount /mnt/tech_pubs
}

function findmerge()
{ 
    local USAGE="Usage: findmerge <lsco | all | wave | dcm | dcmapp> <print | merge | gmerge>"

    if [[ $# -lt 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    if [[ "$1" -ne "all" && "$1" -ne "wave" && "$1" -ne "dcm" && "$1" -ne "dcmapp" && "$1" -ne "lsco" && "$2" != "print" && "$2" != "merge" && "$2" != "gmerge" ]]; then
        echo $USAGE
        return 1
    fi

    local BRANCH_NAME=`get_branch_name`
    local CT_CMD="$CLEARTOOL findmerge . -fver .../$BRANCH_NAME/LATEST -$2"
    local SRC="$1"
    local OPERATION_NAME=""

    if [[ "$2" == "print" ]]; then
        OPERATION_NAME="Find merge";    
    else
        OPERATION_NAME="Merging";    
    fi
        


    if [[ "$SRC" == "lsco" ]]; then
        $CLEARTOOL findmerge `ctlsco` -flatest -$2
    elif [[ "$SRC" == "all" ]]; then
        echo "$OPERATION_NAME under wave source ..."
        cdsrc wave; $CT_CMD

        echo "$OPERATION_NAME under dcm source ..."
        cdsrc dcm; $CT_CMD

        echo "$OPERATION_NAME under dcm application ..."
        cdsrc dcmapp; $CT_CMD
    else 
        echo "$OPERATION_NAME under $SRC directory ..."
        cdsrc $SRC; $CT_CMD
    fi
}

function restartdcm()
{
    killdcmpids
    ../startdcm $1
}

function start_cscope()
{
    cscope -d -i "$CTAG_CSCOPE_PATH"/."$CLEARCASE_VIEW"_cscope.files -f "$CTAG_CSCOPE_PATH"/."$CLEARCASE_VIEW"_cscope.out
}

function tagscope()
{
    time tag_scope $@; date
}

function tag_scope()
{
    local SCOPE_PID=""

    if [[ "$1" == "go_src" ]]; then
        set_ctag_cscope_path
    elif [[ "$1" == "mysql" ]]; then
        set_ctag_cscope_path "$1"
    fi

    scope $@ &
    SCOPE_PID=$!
    
    tag $@

    wait $SCOPE_RC
}

function tag()
{
    local TAG_TYPE="$1"
    local TAG_FILE="$2"
    local CURRENT_VIEW=`get_current_view`
    local INTEL_ARCH=`get_intel_os_type`
    local ALL_CTAG_GOPATH_LIST=("${(@s/:/)GOPATH}")
    local ALL_CTAG_PATH_LIST=(
        $BASE_SRC/common_src 
        $BASE_SRC/fabos/bccb
        $BASE_SRC/fabos/src
        $BASE_SRC/fabos/cfos
        $BASE_SRC/fabos/bfos
        $BASE_SRC/build/target26
        $BASE_SRC/tps/ZebOS
    )
    local DCM_CTAG_PATH_LIST=(
        $BASE_SRC/common_src/fos/common/include
        $BASE_SRC/fabos/src/include
        $BASE_SRC/fabos/bccb/include
        $BASE_SRC/fabos/src/sys/dev/raslog/xml
        $BASE_SRC/fabos/bccb/dsf/Wave/source
        $BASE_SRC/fabos/src/vcs/dcm/source
        $BASE_SRC/fabos/src/vcs/dcm/application
        $BASE_SRC/fabos/src/vcs/dcm/TestApp
        $BASE_SRC/fabos/src/vcs/dcm/build/Dcm/Linux/$INTEL_ARCH/debug/DynamicSource
        $BASE_SRC/fabos/src/yang
        $BASE_SRC/fabos/src/confd/cli
    )
    local ALL_CTAG_MYSQL_LIST=(
        /home/badaniya/workspace/MariaDB 
    )

    if [[ -z "$TAG_FILE" ]]; then
        TAG_FILE="$CTAG_CSCOPE_PATH"/."$CURRENT_VIEW"_tags
    fi

    local ORIGINAL_DIR=`pwd`
    local IS_FIRST_ITERATION=1

    if [[ "$TAG_TYPE" == "go_src" ]]; then
        for CTAG_PATH in "${ALL_CTAG_GOPATH_LIST[@]}"; do
            if [[ `pwd` =~ $CTAG_PATH ]]; then
                if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                    echo -e "[Creating ctag file for \"$CTAG_PATH\" ...]\n    - $TAG_FILE"
                    rm -f "$TAG_FILE"; cd "$CTAG_PATH"; ctags -Rf "$TAG_FILE" --tag-relative=yes --links=no *
                    IS_FIRST_ITERATION=0
                else
                    echo "[Appending ctag file for \"$CTAG_PATH\" ...]"
                    cd "$CTAG_PATH"; ctags -Raf "$TAG_FILE" --tag-relative=yes --links=no *
                fi
            fi
        done
    elif [[ "$TAG_TYPE" == "mysql" ]]; then
        for CTAG_PATH in "${ALL_CTAG_MYSQL_LIST[@]}"; do
            if [[ `pwd` =~ $CTAG_PATH ]]; then
                if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                    echo -e "[Creating ctag file for \"$CTAG_PATH\" ...]\n    - $TAG_FILE"
                    rm -f "$TAG_FILE"; cd "$CTAG_PATH"; ctags -Rf "$TAG_FILE" --tag-relative=yes --links=no *
                    IS_FIRST_ITERATION=0
                else
                    echo "[Appending ctag file for \"$CTAG_PATH\" ...]"
                    cd "$CTAG_PATH"; ctags -Raf "$TAG_FILE" --tag-relative=yes --links=no *
                fi
            fi
        done
    elif [[ "$TAG_TYPE" == "all_src" ]]; then
        for CTAG_PATH in "${ALL_CTAG_PATH_LIST[@]}"; do
            if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                echo -e "[Creating ctag file for \"$CTAG_PATH\" ...]\n    - $TAG_FILE"
                rm -f "$TAG_FILE"; cd "$CTAG_PATH"; ctags -Rf "$TAG_FILE" --tag-relative=yes --links=no *
                IS_FIRST_ITERATION=0
            else
                echo "[Appending ctag file for \"$CTAG_PATH\" ...]"
                cd "$CTAG_PATH"; ctags -Raf "$TAG_FILE" --tag-relative=yes --links=no *
            fi
        done
    else
        for CTAG_PATH in "${DCM_CTAG_PATH_LIST[@]}"; do
            if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                echo -e "[Creating ctag file for \"$CTAG_PATH\" ...]\n    - $TAG_FILE"
                cd "$CTAG_PATH"; rm -f "$TAG_FILE"; ctags -Rf "$TAG_FILE" --tag-relative=yes --links=no *
                IS_FIRST_ITERATION=0
            else
                echo "[Appending ctag file for \"$CTAG_PATH\" ...]"
                cd "$CTAG_PATH"; ctags -Raf "$TAG_FILE" --tag-relative=yes --links=no *
            fi
        done
    fi
    
    echo -e "[Ctags file created.]\n    - $TAG_FILE"

    cd $ORIGINAL_DIR
}

function scope()
{
    local SCOPE_TYPE="$1"
    local SCOPE_FILEPREFIX="$2"
    local CURRENT_VIEW=`get_current_view`
    local ORIGINAL_TEMP_DIR=`echo $TMPDIR`
    local INTEL_ARCH=`get_intel_os_type`
    local FILE_EXTENSIONS="-name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' -o -name '*.sh.in' -o -name '*.xml' -o -name '*.yang' -o -name '*.cli' -o -name '*.go'"
    local ALL_CSCOPE_GOPATH_LIST=("${(@s/:/)GOPATH}")
    local ALL_CSCOPE_PATH_LIST=(
        $BASE_SRC/common_src 
        $BASE_SRC/fabos/bccb
        $BASE_SRC/fabos/src
        $BASE_SRC/fabos/cfos
        $BASE_SRC/fabos/bfos
        $BASE_SRC/build/target26
        $BASE_SRC/tps/ZebOS
    )
    local DCM_CSCOPE_PATH_LIST=(
        $BASE_SRC/common_src/fos/common/include
        $BASE_SRC/fabos/src/include
        $BASE_SRC/fabos/bccb/include
        $BASE_SRC/fabos/src/sys/dev/raslog/xml
        $BASE_SRC/fabos/bccb/dsf/Wave/source
        $BASE_SRC/fabos/src/vcs/dcm/source
        $BASE_SRC/fabos/src/vcs/dcm/application
        $BASE_SRC/fabos/src/vcs/dcm/TestApp
        $BASE_SRC/fabos/src/vcs/dcm/build/Dcm/Linux/$INTEL_ARCH/debug/DynamicSource
        $BASE_SRC/fabos/src/yang
        $BASE_SRC/fabos/src/confd/cli
    )
    local ALL_CSCOPE_MYSQL_LIST=(
        /home/badaniya/workspace/MariaDB 
    )

    if [[ -z "$SCOPE_FILEPREFIX" ]]; then
        SCOPE_FILEPREFIX="$CTAG_CSCOPE_PATH"/."$CURRENT_VIEW"_cscope
    fi 

    local SCOPE_FILE="$SCOPE_FILEPREFIX".file
    local SCOPE_OUTFILE="$SCOPE_FILEPREFIX".out
    local IS_FIRST_ITERATION=1

    if [[ "$SCOPE_TYPE" == "go_src" ]]; then
        for CSCOPE_PATH in "${ALL_CSCOPE_GOPATH_LIST[@]}"; do
            if [[ `pwd` =~ $CSCOPE_PATH ]]; then
                if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                    echo -e "[Creating cscope input file list for \"$CSCOPE_PATH\" ...]\n    - $SCOPE_FILE"
                    eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print > $SCOPE_FILE"
                    IS_FIRST_ITERATION=0
                else
                    echo "[Appending cscope input file list for \"$CSCOPE_PATH\" ...]"
                    eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print >> $SCOPE_FILE"
                fi
            fi
        done
    elif [[ "$SCOPE_TYPE" == "mysql" ]]; then
        for CSCOPE_PATH in "${ALL_CSCOPE_MYSQL_LIST[@]}"; do
            if [[ `pwd` =~ $CSCOPE_PATH ]]; then
                if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                    echo -e "[Creating cscope input file list for \"$CSCOPE_PATH\" ...]\n    - $SCOPE_FILE"
                    eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print > $SCOPE_FILE"
                    IS_FIRST_ITERATION=0
                else
                    echo "[Appending cscope input file list for \"$CSCOPE_PATH\" ...]"
                    eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print >> $SCOPE_FILE"
                fi
            fi
        done
    elif [[ "$SCOPE_TYPE" == "all_src" ]]; then
        for CSCOPE_PATH in "${ALL_CSCOPE_PATH_LIST[@]}"; do
            if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                echo -e "[Creating cscope input file list for \"$CSCOPE_PATH\" ...]\n    - $SCOPE_FILE"
                eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print > $SCOPE_FILE"
                IS_FIRST_ITERATION=0
            else
                echo "[Appending cscope input file list for \"$CSCOPE_PATH\" ...]"
                eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print >> $SCOPE_FILE"
            fi
        done
    else
        for CSCOPE_PATH in "${DCM_CSCOPE_PATH_LIST[@]}"; do
            if [[ "$IS_FIRST_ITERATION" -eq "1" ]]; then
                echo -e "[Creating cscope input file list for \"$CSCOPE_PATH\" ...]\n    - $SCOPE_FILE"
                eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print > $SCOPE_FILE"
                IS_FIRST_ITERATION=0
            else
                echo "[Appending cscope input file list for \"$CSCOPE_PATH\" ...]"
                eval "find $CSCOPE_PATH \( $FILE_EXTENSIONS \) -type f -print >> $SCOPE_FILE"
            fi
        done
    fi

    if [[ -f "$SCOPE_OUTFILE" ]]; then
        echo "[Cleaning up existing cscope cross-reference file ...]"
        rm -rf "$SCOPE_OUTFILE*"
    fi

    # Temporarily set the tmp directory to the cscope path when building the cscope cross reference file

    export TMPDIR="$CTAG_CSCOPE_PATH"

    echo "[Generating cscope cross-reference file ...]"
    cscope -bqi "$SCOPE_FILE" -f "$SCOPE_OUTFILE"
    echo -e "[Cscope file created.]\n    - $SCOPE_OUTFILE"

    export TMPDIR="$ORIGINAL_TEMP_DIR"
}

# Expect dependency
function expect_slx()
{
    local USAGE="Usage: expect_slx <hostname or ip> <username> <password> <ssh options> <ssh command>"

    if [[ $# -lt 5 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local EXPECT_SSH_TIMEOUT="-1"
    local EXPECT_SSH_HOST="$1"
    local EXPECT_SSH_LOGIN="$2"
    local EXPECT_SSH_PASSWD="$3"
    local EXPECT_SSH_OPTIONS="$4"
    local EXPECT_SSH_CMD=$5

    if [[ -n "$EXPECT_SSH_CMD" ]]; then
        EXPECT_SSH_CMD=`printf %q "$EXPECT_SSH_CMD"`
    fi

    OUTPUT=$(expect -c "
    set timeout $EXPECT_SSH_TIMEOUT
    spawn ssh $EXPECT_SSH_OPTIONS $EXPECT_SSH_LOGIN@$EXPECT_SSH_HOST $EXPECT_SSH_CMD
    expect \"*assword:*\"
    send \"$EXPECT_SSH_PASSWD\r\"
    expect \"*#*\"
    send \"show ver\r\"
    expect eof
    ")

    echo -e "\n
======= [expect_ssh started on ($EXPECT_SSH_HOST)] =======
[SSH COMMAND]:
ssh $EXPECT_SSH_OPTIONS $EXPECT_SSH_LOGIN@$EXPECT_SSH_HOST \"$EXPECT_SSH_CMD\"

[OUTPUT]:
$OUTPUT
======= [expect_ssh finished on ($EXPECT_SSH_HOST)] =======\n"
}

function expect_ssh()
{
    local USAGE="Usage: expect_ssh <hostname or ip> <username> <password> <ssh options> <ssh command>"

    if [[ $# -lt 5 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local EXPECT_SSH_TIMEOUT="-1"
    local EXPECT_SSH_HOST="$1"
    local EXPECT_SSH_LOGIN="$2"
    local EXPECT_SSH_PASSWD="$3"
    local EXPECT_SSH_OPTIONS="$4"
    local EXPECT_SSH_CMD=$5

    if [[ -n "$EXPECT_SSH_CMD" ]]; then
        EXPECT_SSH_CMD=`printf %q "$EXPECT_SSH_CMD"`
    fi

    OUTPUT=$(expect -c "
    set timeout $EXPECT_SSH_TIMEOUT
    spawn ssh $EXPECT_SSH_OPTIONS $EXPECT_SSH_LOGIN@$EXPECT_SSH_HOST $EXPECT_SSH_CMD
    expect \"*assword:*\"
    send \"$EXPECT_SSH_PASSWD\r\"
    expect eof
    ")
    
    echo -e "\n
======= [expect_ssh started on ($EXPECT_SSH_HOST)] =======
[SSH COMMAND]:
ssh $EXPECT_SSH_OPTIONS $EXPECT_SSH_LOGIN@$EXPECT_SSH_HOST \"$EXPECT_SSH_CMD\"

[OUTPUT]:
$OUTPUT
======= [expect_ssh finished on ($EXPECT_SSH_HOST)] =======\n"
}

function multiple_expect_ssh()
{
    if [ $# -lt 2 ]; then
        echo "Usage: multiple_expect_ssh <\"non-interactive command\"> [username,password - example: 'root,fibranne' -  default: 'root'] <ip address(es)>"
        return 1
    fi

    local SSH_CMD="$1"
    shift

    # Check for username and password
    local USERNAME="root"
    local PASSWORD=""

    if [[ "$1" =~ [A-Za-z] ]]; then
        ORIGINAL_IFS=$IFS
        IFS=','
        local USERPASS=($1)
        IFS=$ORIGINAL_IFS

        USERNAME="${USERPASS[1]}"
        PASSWORD="${USERPASS[2]}"
        shift
    fi

    # Callisto switches hang when a public key is offered during ssh/scp operations
    local SSH_OPTIONS="-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

    if [[ -z "$PASSWORD" ]]; then
        echo ""
        echo "Enter common password for $USERNAME: "
        read -s USER_PASSWD
    fi

    echo "[multiple_expect_ssh : Remotely executing on $@ ...]"

    # Turn off shell monitoring of backgrounded processes.
    set +m
    
    for i in "$@"; do
        { expect_ssh "$i" "$USERNAME" "$USER_PASSWD" "$SSH_OPTIONS" "$SSH_CMD" & } 2>/dev/null
    done

    wait

    # Turn on shell monitoring of backgrounded processes.
    set -m

    echo "[multiple_expect_ssh completed.]"
}

function expect_scp()
{
    local USAGE="Usage: expect_scp <scp command string - including source and destination> <scp options> <password>"

    if [[ $# -lt 3 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local EXPECT_SCP_TIMEOUT="-1"
    local EXPECT_SCP_CMD="$1"
    local EXPECT_SCP_OPTIONS="$2"
    local EXPECT_SCP_PASSWD="$3"

    #if [[ -n "$EXPECT_SCP_CMD" ]]; then
    #    EXPECT_SCP_CMD=`printf %q "$EXPECT_SCP_CMD"`
    #fi

    OUTPUT=$(expect -c "
    set timeout $EXPECT_SCP_TIMEOUT
    spawn scp $EXPECT_SCP_OPTIONS $EXPECT_SCP_CMD
    expect \"*assword:*\"
    send \"$EXPECT_SCP_PASSWD\r\"
    expect eof
    ")
   
    echo -e "\n
======= [expect_scp started] =======
[SCP COMMAND]:
scp $EXPECT_SCP_OPTIONS \"$EXPECT_SCP_CMD\"

[OUTPUT]:
$OUTPUT
======= [expect_scp finished] =======\n"
}

function multiple_expect_scp()
{
    if [ $# -lt 3 ]; then
        echo "Usage: multiple_expect_scp <source - local file path> <destination - remote file path> <ip address(es)>"
        return 1
    fi

    local SCP_SOURCE_PATH="$1"
    shift
    local SCP_DESTINATION_PATH="$1"
    shift

    # Callisto switches hang when a public key is offered during ssh/scp operations
    local SCP_OPTIONS="-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

    echo ""
    echo "Enter common root scp password: "
    read -s ROOT_PASSWD

    echo "[multiple_expect_scp : Remotely copying to $@ ...]"

    # Turn off shell monitoring of backgrounded processes.
    set +m

    for i in "$@"; do
        local SCP_CMD="$SCP_SOURCE_PATH root@$i:$SCP_DESTINATION_PATH"
        { expect_scp "$SCP_CMD" "$SCP_OPTIONS" "$ROOT_PASSWD" & } 2>/dev/null
    done

    wait

    # Turn on shell monitoring of backgrounded processes.
    set -m

    echo "[multiple_expect_scp completed.]"
}

function multiple_expect_remote_to_local_scp()
{
    if [ $# -lt 3 ]; then
        echo "Usage: multiple_expect_remote_to_local_scp <source - remote file path> <destination - local file path> <ip address(es)>"
        return 1
    fi

    local SCP_SOURCE_PATH="$1"
    shift
    local SCP_DESTINATION_PATH="$1"
    shift

    # Callisto switches hang when a public key is offered during ssh/scp operations
    local SCP_OPTIONS="-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

    echo ""
    echo "Enter common root scp password: "
    read -s ROOT_PASSWD

    echo "[multiple_expect_remote_to_local_scp : Remotely copying from $@ ...]"

    # Turn off shell monitoring of backgrounded processes.
    set +m

    for i in "$@"; do
        if [[ ! -d "$SCP_DESTINATION_PATH/$i" ]]; then
            mkdir -p "$SCP_DESTINATION_PATH/$i"
        fi

        local SCP_CMD="root@$i:$SCP_SOURCE_PATH $SCP_DESTINATION_PATH/$i"
        { expect_scp "$SCP_CMD" "$SCP_OPTIONS" "$ROOT_PASSWD" & } 2>/dev/null
    done

    wait

    # Turn on shell monitoring of backgrounded processes.
    set -m

    echo "[multiple_expect_remote_to_local_scp completed.]"
}

function expect_telnet()
{
    local USAGE="Usage: expect_telnet <hostname or ip> <username> <password> <telnet command>"

    if [[ $# -lt 4 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local EXPECT_TELNET_TIMEOUT="-1"
    local EXPECT_TELNET_HOST="$1"
    local EXPECT_TELNET_LOGIN="$2"
    local EXPECT_TELNET_PASSWD="$3"
    local EXPECT_TELNET_CMD="$4"
    local CTRL_C="\003"

    if [[ -n "$EXPECT_TELNET_CMD" ]]; then
        EXPECT_TELNET_CMD=`printf %q "$EXPECT_TELNET_CMD"`
    fi

    OUTPUT=$(expect -c "
    set timeout $EXPECT_TELNET_TIMEOUT 
    spawn telnet -l $EXPECT_TELNET_LOGIN $EXPECT_TELNET_HOST
    expect \"*assword:*\"
    send \"$EXPECT_TELNET_PASSWD\r\"
    expect {
        \"*Control-C*\"                 { send \"$CTRL_C\"; exp_continue }
        \"*$EXPECT_TELNET_LOGIN>*\"     { send \"$EXPECT_TELNET_CMD\r\" }
        \"*$EXPECT_TELNET_LOGIN*#*\"    { send \"$EXPECT_TELNET_CMD\r\" }
        eof
    }
    ") 

    echo -e "\n
======= [expect_telnet started on ($EXPECT_TELNET_HOST)] =======
[TELNET COMMAND]:
telnet -l $EXPECT_TELNET_LOGIN $EXPECT_TELNET_HOST \"$EXPECT_TELNET_CMD\"

[OUTPUT]:
$OUTPUT
======= [expect_telnet finished on ($EXPECT_TELNET_HOST)] =======\n"
}

function multiple_expect_telnet()
{
    if [ $# -lt 2 ]; then
        echo "Usage: multiple_expect_telnet <\"non-interactive command\"> <ip address(es)>"
        return 1
    fi

    local TELNET_CMD="$1"
    shift

    # Check for username and password
    local USERNAME="root"
    local PASSWORD=""

    if [[ "$1" =~ [A-Za-z] ]]; then
        ORIGINAL_IFS=$IFS
        IFS=','
        local USERPASS=($1)
        IFS=$ORIGINAL_IFS

        USERNAME="${USERPASS[1]}"
        PASSWORD="${USERPASS[2]}"
        shift
    fi

    if [[ -z "$PASSWORD" ]]; then
        echo ""
        echo "Enter common password for $USERNAME: "
        read -s USER_PASSWD
    fi

    echo "[multiple_expect_telnet : Remotely executing on $@ ...]"

    # Turn off shell monitoring of backgrounded processes.
    set +m

    for i in "$@"; do
        { expect_telnet "$i" "$USERNAME" "$USER_PASSWD" "$TELNET_CMD" & } 2>/dev/null
    done

    wait

    # Turn on shell monitoring of backgrounded processes.
    set -m

    echo "[multiple_expect_telnet completed.]"
}

function expect_firmwaredownload()
{
    local USAGE="Usage: expect_firmwaredownload <hostname or ip> <username> <password> <firmware path> [--default-config]>"

    if [[ $# -lt 5 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local EXPECT_TELNET_TIMEOUT="-1"
    local EXPECT_TELNET_HOST="$1"
    local EXPECT_TELNET_LOGIN="$2"
    local EXPECT_TELNET_PASSWD="$3"
    local EXPECT_TELNET_FWDL_PATH="$4"
    local EXPECT_TELNET_DEFAULT="$5"
    local EXPECT_EXIT_CODE=0
    local CTRL_C="\003"

    local FWCOMMIT_CMD="/fabos/cliexec/firmwarecommit"
    local FWDL_CMD="/fabos/cliexec/firmwaredownload"
    local FWDL_OPTIONS="-snb"
    local FWDL_USER="releaseuser"
    local FWDL_PASS="releaseuser"

    if [[ "$EXPECT_TELNET_DEFAULT" == "--default-config" ]]; then
        FWDL_OPTIONS="${FWDL_OPTIONS}d"
    fi

    local EXPECT_FWDL_CMD="echo y | $FWCOMMIT_CMD; $FWDL_CMD $FWDL_OPTIONS $FWDL_HOST,$FWDL_USER,$FWDL_PATH,$FWDL_PASS"

    OUTPUT=$(expect -c "
    set timeout 15
    spawn telnet -l $EXPECT_TELNET_LOGIN $EXPECT_TELNET_HOST
    expect {
        timeout                                                         { puts \"$expect_out(buffer)\"; exit 1 }
        \"*assword:*\"                                                  { sleep 1; send \"$EXPECT_TELNET_PASSWD\r\" }
        \"No route to host\"                                            { puts \"$expect_out(buffer)\"; exit 2 }
    }
    expect {
        \"Login incorrect\"                                             { puts \"$expect_out(buffer)\"; exit 3 }
        \"Your account is disabled\"                                    { puts \"$expect_out(buffer)\"; exit 12 }
        \"Connection closed by foreign host\"                           { puts \"$expect_out(buffer)\"; exit 13 }
        \"Max remote sessions\"                                         { puts \"$expect_out(buffer)\"; exit 14 }
        \"*Control-C*\"                                                 { send \"$CTRL_C\"; exp_continue }
        \"*$EXPECT_TELNET_LOGIN>*\"                                     { send \"$EXPECT_FWDL_CMD\r\"; set timeout $EXPECT_TELNET_TIMEOUT }
        \"*$EXPECT_TELNET_LOGIN*#*\"                                    { send \"$EXPECT_FWDL_CMD\r\"; set timeout $EXPECT_TELNET_TIMEOUT }
    }
    expect {
        \"The server is inaccessible or firmware path is invalid*\"     { puts \"$expect_out(buffer)\"; exit 4 }
        \"Cannot download the same firmware version*\"                  { puts \"$expect_out(buffer)\"; exit 5 }
        \"Firmwaredownload failed because another session is running*\" { puts \"$expect_out(buffer)\"; exit 6 }
        \"The preinstall script failed\"                                { puts \"$expect_out(buffer)\"; exit 7 }
        \"*support*\"                                                   { puts \"$expect_out(buffer)\"; exit 8 }
        \"*Command failed*\"                                            { puts \"$expect_out(buffer)\"; exit 9 }
        \"Do you want to continue*\"                                    { send \"Y\r\" }
    }
    expect {
        \"All packages have been downloaded successfully*\"             { puts \"$expect_out(buffer)\"; exit 0 }
        \"*failed*\"                                                    { puts \"$expect_out(buffer)\"; exit 10 }
        \"*faulty state*\"                                              { puts \"$expect_out(buffer)\"; exit 11 }
        \"*$EXPECT_TELNET_LOGIN>*\"                                     { exit 0 } 
        \"*$EXPECT_TELNET_LOGIN*#*\"                                    { exit 0 } 
    }

    expect eof
    catch wait result
    exit [lindex \$result 3]
    "); EXPECT_EXIT_CODE=$?

    echo -e "\n
======= [expect_firmwaredownload started on ($EXPECT_TELNET_HOST)] =======
[FIRMWAREDOWNLOAD COMMAND]:
telnet -l $EXPECT_TELNET_LOGIN $EXPECT_TELNET_HOST \"$EXPECT_FWDL_CMD\"

[OUTPUT]:
$OUTPUT
======= [expect_firmwaredownload finished on ($EXPECT_TELNET_HOST => Exit Code : $EXPECT_EXIT_CODE)] =======\n"

    return $EXPECT_EXIT_CODE
}

function multiple_expect_firmwaredownload()
{
    local USAGE="Usage: multiple_expect_firmwaredownload [--default-config] <full firmware path> <filename containing ip addresses [additional ipaddress(es)] | ipaddress(es)>"

    if [[ $# -lt 2 ]]; then
        echo "$USAGE"
        return 1
    fi

    # Associative arrays for background process status
    declare -A PIDS
    declare -A RETURN_STATUS

    local SUCESSFUL_IP_ADDRESSES=""
    local FAILED_IP_ADDRESSES=""
    local DEFAULT_CONFIG=""
    local IPLIST_FILENAME=""
    local IPLIST=()

    for i in "$@"; do
        if [[ "$i" =~ ^--default-config$ ]]; then
            DEFAULT_CONFIG="$i" 
        elif [[ "$i" =~ ^[0-9.]+$ ]]; then
            IPLIST+=("$i")
        elif [[ -f "$i" ]]; then
            IPLIST_FILENAME="$i"
            IPLIST+=( $(cat $IPLIST_FILENAME) )
        elif [[ -d "$i" ]]; then
            FWDL_PATH="$i"
        else
            echo "$USAGE"
            echo "Unrecognized option \"$i\"."
        fi
    done

    if [[ -z "$FWDL_PATH" ]]; then
        echo "$USAGE"
        echo "No valid firmware path specified!"
        return 1
    fi

    if [[ ${#IPLIST[@]} -eq 0 ]]; then
        echo "$USAGE"
        echo "No IP Address(es) specified!"
        return 1
    else
        IPLIST=( `printf '%s\n' "${IPLIST[@]}" | awk '!a[$0]++'` )
        echo "[IP Address(es) to download firmware]:"
        printf '  - %s\n' "${IPLIST[@]}" 
    fi

    echo ""
    echo "Enter common root password: "
    read -s ROOT_PASSWD

    if [[ -z "$DEFAULT_CONFIG" ]]; then
        echo "[multiple_expect_firmwaredownload : Downloading firmware to ${IPLIST[@]} ...]"
    else
        echo "[multiple_expect_firmwaredownload : Downloading firmware with default-config to ${IPLIST[@]} ...]"
    fi

    # Turn off shell monitoring of backgrounded processes.
    set +m

    for i in "${IPLIST[@]}"; do
        { expect_firmwaredownload "$i" "root" "$ROOT_PASSWD" "$FWDL" "$DEFAULT_CONFIG" & } 2>/dev/null
        PIDS["$i"]=$!
    done

    for i in "${IPLIST[@]}"; do
        wait ${PIDS["$i"]}
        RETURN_STATUS["$i"]=$?
    done

    # Turn on shell monitoring of backgrounded processes.
    set -m

    for i in "${IPLIST[@]}"; do
        if [[ 0 -eq ${RETURN_STATUS[$i]} ]]; then
            if [[ -z "$SUCESSFUL_IP_ADDRESSES" ]]; then
                SUCESSFUL_IP_ADDRESSES="$i"
            else
                SUCESSFUL_IP_ADDRESSES="$SUCESSFUL_IP_ADDRESSES $i"
            fi
        else
            if [[ -z "$FAILED_IP_ADDRESSES" ]]; then
                FAILED_IP_ADDRESSES="$i"
            else
                FAILED_IP_ADDRESSES="$FAILED_IP_ADDRESSES $i"
            fi
        fi
    done

    echo "[multiple_expect_firmwaredownload : Overall completion status]:"

    if [[ -n "$SUCESSFUL_IP_ADDRESSES" && -z "$FAILED_IP_ADDRESSES" ]]; then
        echo "Firmwaredownload has completed successfully on all entries ($SUCESSFUL_IP_ADDRESSES)."
    elif [[ -n "$SUCESSFUL_IP_ADDRESSES" && -n "$FAILED_IP_ADDRESSES" ]]; then
        echo "Firmwaredownload has completed successfully on ($SUCESSFUL_IP_ADDRESSES)"
        echo "    and failed on ($FAILED_IP_ADDRESSES)."
    elif [[ -z "$SUCESSFUL_IP_ADDRESSES" && -n "$FAILED_IP_ADDRESSES" ]]; then
        echo "Firmwaredownload has failed on all entries ($FAILED_IP_ADDRESSES)."
    elif [[ -z "$SUCESSFUL_IP_ADDRESSES" && -z "$FAILED_IP_ADDRESSES"  ]]; then
        echo "multiple_expect_firmwaredownload could not obtain return status for all entries ($@)"
    else
        echo "multiple_expect_firmwaredownload failed to get return status for all entries ($@)"
    fi

    local COUNT=0

    for i in "${!RETURN_STATUS[@]}"; do
        ((COUNT++))
        echo -e "    $COUNT)\t$i\t=> Exit Code : ${RETURN_STATUS[$i]}"
    done
}

function xml_builder()
{
    local INPUT=("$@")
    local FIRST="$INPUT"

    ORIGINAL_IFS=$IFS
    IFS='='
    local EXPECT_NETCONF_CMD_PARTS=($FIRST)
    IFS=$ORIGINAL_IFS

    if [[ ${#EXPECT_NETCONF_CMD_PARTS[@]} -gt 1 ]]; then
        echo -e "<${EXPECT_NETCONF_CMD_PARTS[1]}>${EXPECT_NETCONF_CMD_PARTS[2]}</${EXPECT_NETCONF_CMD_PARTS[1]}>"

        if [[ ${#INPUT[@]} -gt 1 ]]; then
            INPUT=("${INPUT[@]:1}")
            xml_builder "${INPUT[@]}"
        fi
    else
        local EXPECT_NETCONF_XMLNS="${XMLNS_MAP[$EXPECT_NETCONF_CMD_PARTS]}"

        if [[ -n "$EXPECT_NETCONF_XMLNS" ]]; then
            echo -e "<"$EXPECT_NETCONF_CMD_PARTS" xmlns=\\"\""$EXPECT_NETCONF_XMLNS"\\"\">"    
        else
            echo -e "<"$EXPECT_NETCONF_CMD_PARTS">"
        fi
        
        if [[ ${#INPUT[@]} -gt 1 ]]; then
            INPUT=("${INPUT[@]:1}")
            xml_builder "${INPUT[@]}"
        fi

        echo -e "</"$EXPECT_NETCONF_CMD_PARTS">"
    fi
}

function expect_netconf()
{
    local USAGE="Usage: expect_netconf <hostname or ip> <username> <password> <netconf command>"

    if [[ $# -lt 4 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    local EXPECT_SSH_TIMEOUT="-1"
    local EXPECT_NETCONF_HOST="$1"
    local EXPECT_NETCONF_LOGIN="$2"
    local EXPECT_NETCONF_PASSWD="$3"
    local EXPECT_NETCONF_CMDS="$4"
    local EXPECT_SSH_OPTIONS="-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
    local EXPECT_NETCONF_OPTIONS="-s netconf"
    NETCONF_XMLNS=(`get_netconf_xmlns`)

    if [[ ${#NETCONF_XMLNS[@]} -eq 0 ]]; then
        echo -e "Error: get_netconf_xmlns() did not return any results!\nPlease ensure \"get_netconf_xmlns --update\" has been called with a proper clearcase view set under a compiled YANG directory."
        return 2
    fi

    eval "declare -A XMLNS_MAP=(`get_netconf_xmlns`)"

    local EXPECT_NETCONF_HELLO_CAPABILITIES="<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n<hello xmlns=\\\"urn:ietf:params:xml:ns:netconf:base:1.0\\\">\n<capabilities>\n<capability>urn:ietf:params:netconf:base:1.0</capability>\n</capabilities>\n</hello>\n]]>]]>"
    local EXPECT_NETCONF_RPC_START_TAG="<rpc xmlns=\\\"urn:ietf:params:xml:ns:netconf:base:1.0\\\" message-id=\\\"1\\\">"
    local EXPECT_NETCONF_RPC_END_TAG="</rpc>"
    local EXPECT_NETCONF_XMLNS=""
    local EXPECT_NETCONF_XML_CMD=""
    local EXPECT_NETCONF_RPC=()

    local EXPECT_NETCONF_CMDS_ARRAY=($EXPECT_NETCONF_CMDS)

    local ORIGINAL_IFS=$IFS
    IFS=','

    for EXPECT_NETCONF_CMD in ${EXPECT_NETCONF_CMDS_ARRAY[@]}; do
        local EXPECT_NETCONF_CMD_ARRAY=($EXPECT_NETCONF_CMD)

        if [[ "$EXPECT_NETCONF_CMD_ARRAY" == "get-config" ]]; then
            # Show running-config equivalent NETCONF Request
            local ELEMENT="$EXPECT_NETCONF_CMD_ARRAY"

            EXPECT_NETCONF_XML_CMD="<"$ELEMENT">\n<source>\n<running>\n</running>\n</source>\n"

            if [[ ${#EXPECT_NETCONF_CMD_ARRAY[@]} -gt 1 ]]; then
                # Filtered show running-config

                EXPECT_NETCONF_XML_CMD+="<filter type=\\"\"subtree\\"\">\n"

                EXPECT_NETCONF_CMD_ARRAY=("${EXPECT_NETCONF_CMD_ARRAY[@]:1}")

                EXPECT_NETCONF_XML_CMD+=`xml_builder "${EXPECT_NETCONF_CMD_ARRAY[@]}"`

                EXPECT_NETCONF_XML_CMD+="\n</filter>\n"
            fi

            EXPECT_NETCONF_XML_CMD+="</"$ELEMENT">"
        else
            # NETCONF Custom RPC Request

            EXPECT_NETCONF_XMLNS="${XMLNS_MAP[$EXPECT_NETCONF_CMD_ARRAY]}"

            if [[ ${#EXPECT_NETCONF_CMD_ARRAY[@]} -eq 1 ]]; then
                # RPC Request without input

                EXPECT_NETCONF_XML_CMD="<"$EXPECT_NETCONF_CMD" xmlns=\\"\""$EXPECT_NETCONF_XMLNS"\\"\">\n</"$EXPECT_NETCONF_CMD">"
            else
                # RPC Request with input

                local NETCONF_ELEMENT="$EXPECT_NETCONF_CMD_ARRAY"

                EXPECT_NETCONF_XML_CMD="<"$NETCONF_ELEMENT" xmlns=\\"\""$EXPECT_NETCONF_XMLNS"\\"\">\n"
                EXPECT_NETCONF_CMD_ARRAY=("${EXPECT_NETCONF_CMD_ARRAY[@]:1}")

                EXPECT_NETCONF_XML_CMD+=`xml_builder "${EXPECT_NETCONF_CMD_ARRAY[@]}"`

                EXPECT_NETCONF_XML_CMD+="\n</"$NETCONF_ELEMENT">"
            fi
        fi

        EXPECT_NETCONF_RPC+=($EXPECT_NETCONF_HELLO_CAPABILITIES"\n"$EXPECT_NETCONF_RPC_START_TAG"\n"$EXPECT_NETCONF_XML_CMD"\n"$EXPECT_NETCONF_RPC_END_TAG)
    done

    OUTPUT=$(expect -c "
    set timeout $EXPECT_SSH_TIMEOUT
    spawn ssh $EXPECT_SSH_OPTIONS $EXPECT_NETCONF_LOGIN@$EXPECT_NETCONF_HOST $EXPECT_NETCONF_OPTIONS
    expect \"*assword:*\"
    send \"$EXPECT_NETCONF_PASSWD\r\"
    expect \"]]>]]>\"
    send \"$EXPECT_NETCONF_RPC\r\"
    expect \"</rpc-reply>]]>]]>\"
    ")
   
    echo -e "\n
======= [expect_netconf started on ($EXPECT_NETCONF_HOST)] =======
[NETCONF COMMAND]:
$EXPECT_NETCONF_RPC

[OUTPUT]:
$OUTPUT
======= [expect_netconf finished on ($EXPECT_NETCONF_HOST)] =======\n"

    IFS=$ORIGINAL_IFS
}

function get_netconf_xmlns()
{
    local USAGE="Usage: get_netconf_xmlns [--update]"
    local UPDATE=$1
    local NETCONF_XMLNS_FILENAME="$HOME/.netconf_xmlns"
    local NETCONF_XMLNS=""

    if [[ -n "$1" && "$1" != "--update" || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    if [[ "$UPDATE" == "--update" ]]; then
        NETCONF_XMLNS1=`grep "rpc name=" *.xml 2>/dev/null | sed -n 's/^\(.*\):.*"\(.*\)".*$/\2:\1/p' | awk -F ':' '{printf ("[%s]=", $1); system("grep namespace " $2 " | sed \"s/.*<namespace uri=//g\" | sed \"s@/>@@g\" ")}' | sort`
        NETCONF_XMLNS2=`grep "xmlns:" *.xml 2>/dev/null | sed -n 's/.*xmlns:\(.*\)="\(.*\)".*/[\1]="\2"/p' | sort | uniq`

        if [[ -n "$NETCONF_XMLNS1" && -n "$NETCONF_XMLNS2" ]]; then
            NETCONF_XMLNS=`echo -e "$NETCONF_XMLNS1\n$NETCONF_XMLNS2" | sort | uniq`
            echo -e "$NETCONF_XMLNS" > $NETCONF_XMLNS_FILENAME
            echo -e "$NETCONF_XMLNS\n\n[Contents written to: $NETCONF_XMLNS_FILENAME]"
        else
            echo -e "Could not find XML namespaces for NETCONF.  Please make sure you are in a directory that has compiled YIN (*.xml) files." >&2
            return 2
        fi
    else
        local UPDATE_MSG="Please run \"get_netconf_xmlns --update\" in a directory that contains compiled YANG files."

        if [[ -f "$NETCONF_XMLNS_FILENAME" ]]; then
            if [[ -s "$NETCONF_XMLNS_FILENAME" ]]; then
                cat "$NETCONF_XMLNS_FILENAME"
            else
                echo -e "Contents of $NETCONF_XMLNS_FILENAME are empty!\n$UPDATE_MSG" >&2
                return 4
            fi
        else
            echo -e "$NETCONF_XMLNS_FILENAME file is missing!\n$UPDATE_MSG" >&2
            return 3
        fi
    fi
}

function curl_brcd()
{
    local USAGE="Usage: curl_brcd <GET | POST | PUT | PATCH | DELETE> <URI> [<Data/Payload for POST|PUT|PATCH Requests> | <Resource Depth for GET Requests: Default is 1>]"
    local REST_OPERATION=$1
    local URI=$2
    local DATA=$3
    local HEADER="Accept: application/vnd.configuration.resource+xml"
    local RESOURCE_DEPTH_HEADER=""
    local USER="admin"
    local PASS="password"

    if [[ $# -lt 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi
 
    if [[ "$REST_OPERATION" != "GET" && "$REST_OPERATION" != "POST" && "$REST_OPERATION" != "PUT" && "$REST_OPERATION" != "PATCH" && "$REST_OPERATION" != "DELETE" ]]; then
        echo $USAGE
        return 2
    fi

    if [[ "$URI" =~ rest[/]?$ ]]; then
        # Remove header for this special case
        HEADER=""
    fi

    if [[ "$REST_OPERATION" == "GET" && -n "$DATA" ]]; then
        # Reusing DATA for Resource Depth
        RESOURCE_DEPTH_HEADER="Resource-Depth: $DATA"
        DATA=""
        echo $RESOURCE_DEPTH_HEADER
    fi

    if [[ -n "$DATA" ]]; then
        echo curl -v -k -X $REST_OPERATION -H \"$HEADER\" -H \"$RESOURCE_DEPTH_HEADER\" -u "$USER":"$PASS" $URI -d \"$DATA\"
        curl -v -k -X $REST_OPERATION -H "$HEADER" -H "$RESOURCE_DEPTH_HEADER" -u "$USER":"$PASS" $URI -d "$DATA"
    else
        echo curl -v -k -X $REST_OPERATION -H \"$HEADER\" -H \"$RESOURCE_DEPTH_HEADER\" -u "$USER":"$PASS" $URI
        curl -v -k -X $REST_OPERATION -H "$HEADER" -H "$RESOURCE_DEPTH_HEADER" -u "$USER":"$PASS" $URI
    fi
}

function get_private_shared_memory()
{
    local USAGE="Usage: get_private_shared_memory <IP Address>"
    local HOST_IP="$1"
    local HOST_CMD='smaps -t `pidof Dcmd.Linux.powerpc` | grep Total | sed -n "s/.* \([0-9]*\) KB | Total$/\1/p"'
    local HOST_OPTIONS='-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    expect_ssh "$HOST_IP" "root" "fibranne" "$HOST_OPTIONS" "$HOST_CMD"
}

function get_process_file_descriptor_usage()
{
    local USAGE="Usage: get_process_file_descriptor_usage <Process Name> <IP Address>"
    local PROCESS_NAME="$1"
    local HOST_IP="$2"
    local HOST_CMD='ls -1 /proc/`pidof '$PROCESS_NAME'`/fd | wc -l'
    local HOST_OPTIONS='-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

    if [[ $# -lt 2 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    expect_ssh "$HOST_IP" "root" "fibranne" "$HOST_OPTIONS" "$HOST_CMD"
}

function get_rbridge_id()
{
    local USAGE="Usage: get_private_shared_memory <IP Address>"
    local HOST_IP="$1"
    local HOST_CMD='cat /etc/fabos/fabos.0.conf | grep fabric.domain | sed -n "s/fabric.domain:\([0-9]\+\).*/\1/p"'
    local HOST_OPTIONS='-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo $USAGE
        return 1
    fi

    expect_ssh "$HOST_IP" "root" "fibranne" "$HOST_OPTIONS" "$HOST_CMD"
}

function get_libfile_type()
{
    if [ $# -lt 1 ]; then
        echo "Usage: get_libfile_type <filename>"
        return 1
    fi

    local FILE_TYPE=`file $1`
    local ELF_TYPE=""
    local ELF_BIT=""

    if [[ "$FILE_TYPE" =~ 'x86-64' ]]; then
        ELF_TYPE='intel'
    elif [[ "$FILE_TYPE" =~ 'Intel' ]]; then
        ELF_TYPE='intel'
    elif [[ "$FILE_TYPE" =~ 'PowerPC' ]]; then
        ELF_TYPE='powerpc'
    fi

    if [[ "$FILE_TYPE" =~ '32-bit' ]]; then
        ELF_BIT='32'
    elif [[ "$FILE_TYPE" =~ '64-bit' ]]; then
        ELF_BIT='64'
    fi
    
    echo "$ELF_TYPE" "$ELF_BIT"
}

function get_libwave_path()
{
    if [ $# -lt 1 ]; then
        echo "Usage: get_libwave_path <swbd#>"
        return 1
    fi

    local SWBD="$1"

    local LIB=`find $BASE_SRC/build/swbd$SWBD/fabos/bccb/dsf/Wave/build/Wave/Linux -name libWave.so.* | grep optimized/lib` 
    echo `dirname "$LIB"`
}

function get_libdcm_path()
{
    if [ $# -lt 1 ]; then
        echo "Usage: get_libdcm_path <swbd#>"
        return 1
    fi

    local SWBD="$1"
    local LIB=`find $BASE_SRC/build/swbd$SWBD/fabos/src/vcs/dcm/build/Dcm/Linux -name libDcm.so.* | grep optimized/lib` 
    echo `dirname "$LIB"`
}

function scp_libs()
{
    if [ $# -lt 4 ]; then
        echo "Usage: scp_libs <all|dcmclient|dcm|wave> <swbd#> <strip|nostrip> <ip address(es)>"
        return 1
    fi

    local LIBWAVE=libWave.so.1.4.0
    local LIBDCM=libDcm.so.1.1.0
    local LIBDCMCLIENT=libDcmClient.so.1.1.0

    local LIB_TYPE="$1"
    shift
    local SWBD="$1"
    shift
    local LIB_STRIP="$1"
    shift

    local LIBWAVE_PATH=`get_libwave_path $SWBD`
    local LIBDCM_PATH=`get_libdcm_path $SWBD`

    # Callisto switches hang when a public key is offered during ssh/scp operations
    local SSH_OPTIONS="-o PubKeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

        
    if [[ "$LIB_TYPE" == "all" || "$LIB_TYPE" == "wave" ]]; then
        if [[ "$LIB_STRIP" == "strip" ]]; then
            echo "Stripping symbols from $LIBWAVE (SWBD$SWBD)"
            strip_lib $LIBWAVE_PATH/$LIBWAVE
        fi

        local cksum=`cksum $LIBWAVE_PATH/$LIBWAVE`
        echo "CKSUM (SWBD$SWBD): $cksum"
    fi

    if [[ "$LIB_TYPE" == "all" || "$LIB_TYPE" == "dcm" ]]; then
        if [[ "$LIB_STRIP" == "strip" ]]; then
            echo "Stripping symbols from $LIBDCM (SWBD$SWBD)"
            strip_lib $LIBDCM_PATH/$LIBDCM
        fi

        local cksum=`cksum $LIBDCM_PATH/$LIBDCM`
        echo "CKSUM (SWBD$SWBD): $cksum"
    fi

    if [[ "$LIB_TYPE" == "all" || "$LIB_TYPE" == "dcmclient" ]]; then
        if [[ "$LIB_STRIP" == "strip" ]]; then
            echo "Stripping symbols from $LIBDCMCLIENT (SWBD$SWBD)"
            strip_lib $LIBDCM_PATH/$LIBDCMCLIENT
        fi

        local cksum=`cksum $LIBDCM_PATH/$LIBDCMCLIENT`
        echo "CKSUM (SWBD$SWBD): $cksum"
    fi

    echo ""
    echo "Enter common root password: "
    read -s ROOT_PASSWD

    echo "[SCP shared lib(s) to $@ ...]"

    for i in "$@"; do
        if [ "$LIB_TYPE" == "all" ]; then
            expect_scp "$LIBWAVE_PATH/$LIBWAVE $LIBDCM_PATH/$LIBDCM $LIBDCM_PATH/$LIBDCMCLIENT root@$i:/tmp" "$SSH_OPTIONS" "$ROOT_PASSWD"
        elif [ "$LIB_TYPE" == "dcmclient" ]; then
            expect_scp "$LIBDCM_PATH/$LIBDCMCLIENT root@$i:/tmp" "$SSH_OPTIONS" "$ROOT_PASSWD"
        elif [ "$LIB_TYPE" == "dcm" ]; then
            expect_scp "$LIBDCM_PATH/$LIBDCM root@$i:/tmp" "$SSH_OPTIONS" "$ROOT_PASSWD"
        elif [ "$LIB_TYPE" == "wave" ]; then
            expect_scp "$LIBWAVE_PATH/$LIBWAVE root@$i:/tmp" "$SSH_OPTIONS" "$ROOT_PASSWD"
        else
            echo "Invalid input"
            return 2
        fi
    done

    echo "[Preparing switch for lib(s) update ...]"

    for i in "$@"; do
        if [ "$LIB_TYPE" == "all" ]; then
            expect_ssh "$i" "root" "$ROOT_PASSWD" "$SSH_OPTIONS" "mv /fabos/lib/$LIBWAVE /root/$LIBWAVE.original && mv /tmp/$LIBWAVE /fabos/lib/$LIBWAVE && sync && mv /fabos/lib/$LIBDCM /root/$LIBDCM.original && mv /tmp/$LIBDCM /fabos/lib/$LIBDCM && sync && mv /fabos/lib/$LIBDCMCLIENT /root/$LIBDCMCLIENT.original && mv /tmp/$LIBDCMCLIENT /fabos/lib/$LIBDCMCLIENT && sync && /sbin/hainfo RebootReason Reload && /sbin/reboot"
        elif [ "$LIB_TYPE" == "dcmclient" ]; then
            expect_ssh "$i" "root" "$ROOT_PASSWD" "$SSH_OPTIONS" "mv /fabos/lib/$LIBDCMCLIENT /root/$LIBDCMCLIENT.original && mv /tmp/$LIBDCMCLIENT /fabos/lib/$LIBDCMCLIENT && sync && /sbin/hainfo RebootReason Reload && /sbin/reboot"
        elif [ "$LIB_TYPE" == "dcm" ]; then
            expect_ssh "$i" "root" "$ROOT_PASSWD" "$SSH_OPTIONS" "mv /fabos/lib/$LIBDCM /root/$LIBDCM.original && mv /tmp/$LIBDCM /fabos/lib/$LIBDCM && sync && /sbin/hainfo RebootReason Reload && /sbin/reboot"
        elif [ "$LIB_TYPE" == "wave" ]; then
            expect_ssh "$i" "root" "$ROOT_PASSWD" "$SSH_OPTIONS" "mv /fabos/lib/$LIBWAVE /root/$LIBWAVE.original && mv /tmp/$LIBWAVE /fabos/lib/$LIBWAVE && sync && /sbin/hainfo RebootReason Reload && /sbin/reboot"
        else
            echo "Invalid input"
            return 2
        fi
    done
    
    echo ""

    return 0
}

function strip_lib()
{
    if [ $# -ne 1 ]; then
        echo "Usage: strip_lib <filename>"
        return 1
    fi

    local LIB_FILE_TYPE=(`get_libfile_type "$1"`)
    local STRIP_CMD=''
 
    if [[ ${LIB_FILE_TYPE[1]} == 'powerpc' ]]; then
        STRIP_CMD='$BASE_SRC/toolchains/ppc/gcc-4.3.74-eglibc-2.8.74-6/powerpc-linux-gnu/bin/powerpc-linux-gnu-strip'
    elif [[ ${LIB_FILE_TYPE[1]} == 'intel' ]]; then
        if [[ ${LIB_FILE_TYPE[2]} == '32' ]]; then
            STRIP_CMD='$BASE_SRC/toolchains/x86/gcc-4.8.2/bin/x86-linux-gnu-strip'
        elif [[ ${LIB_FILE_TYPE[2]} == '64' ]]; then
            STRIP_CMD='$BASE_SRC/toolchains/x86/gcc-4.8.2/bin/x86_64-linux-gnu-strip'
        fi
    fi

    $STRIP_CMD $1

    return 0
}

function get_view_path()
{
    local VIEW_NAME="$1"
    local VIEW_PATH_PREFIX=""

    if [ -z "$VIEW_NAME" ]; then
        echo "$VIEW_PATH_PREFIX"
        return 1
    else
        local VIEW_PATH_PREFIX=`ssh $USER@$CC_HOST $CLEARTOOL lsview|grep $1|awk '{print $2}'|sed 's/\(.*\)\/.view.stg/\1/'`
        echo "$VIEW_PATH_PREFIX"
        return 0
    fi
}

function cd_sview() 
{ 
    local VIEW_PATH_PREFIX=`get_view_path "$1"`

    if [ -n "$VIEW_PATH_PREFIX" ]; then
        cd "$VIEW_PATH_PREFIX"
        return 0
    else
        return 1
    fi
}

function refresh_sview() 
{   
    local STATIC_VIEW_NAME="$1"

    cd_sview "$STATIC_VIEW_NAME"

    if [ $? -eq 0 ]; then
        ssh $USER@$CC_HOST "cd $RETURN; $CLEARTOOL update -force -overwrite -add_loadrules \
        $BASE_SRC/fabos/src $BASE_SRC/fabos/bccb \
        $BASE_SRC/make \
        $BASE_SRC/dist \
        $BASE_SRC/tps/confd \
        $BASE_SRC/tps/ZebOS \
        $BASE_SRC/build \
        $BASE_SRC/target26"
    else
        echo "Not a snapshot view!"
    fi
}

function clean_dcmd()
{
    # save pwd
    local ORIGINAL_DIR=`pwd`
    local PATHS=""
    local MACHINE_TYPE=`uname -m`
    local CLEAN_TYPE="$1"
    local STATIC_VIEW_NAME="$2"
    local STATIC_VIEW_PATH_PREFIX=`get_view_path "$STATIC_VIEW_NAME"`
    local VOB_HOME=""
    local SRC_PATH=""

    if [ -z "$CLEAN_TYPE" ]; then
        echo "Invalid path type specified"
        return 1
    elif [ "all" == "$CLEAN_TYPE" ]; then
        PATHS=( confdlatest ubreeze waveapp dcm dcmapp testapp )
    elif [ "yangcli" == "$CLEAN_TYPE" ]; then
        PATHS=( yang cli datatypes )
    else
        PATHS="$CLEAN_TYPE"
    fi
    
    if [ -n "$STATIC_VIEW_PATH_PREFIX" ]; then
        VOB_HOME="$STATIC_VIEW_PATH_PREFIX"
    else
        VOB_HOME=""
    fi

    echo -e "[Cleaning \"$CLEAN_TYPE\" $MACHINE_TYPE Wave/Dcm Source Areas ...]"

    for i in ${PATHS[@]}; do
        SRC_PATH=`get_src_path "$i"`

        echo "$VOB_HOME/$SRC_PATH"
        cd "$VOB_HOME/$SRC_PATH"

        if [ "confdlatest" != "$i" ]; then
            echo "gmake clean in $VOB_HOME/$SRC_PATH"
            gmake clean
        fi


        if [ "wave" == "$i" ]; then
            echo "rmdir in ../build/Wave/Linux/$MACHINE_TYPE"
            rm -rf ../build/Wave/Linux/$MACHINE_TYPE
        elif [ "ubreeze" == "$i" ]; then
            echo "rmdir in ../build/*"
            rm -rf ../build/*
        elif [ "dcm" == "$i" ]; then
            echo "rmdir in ../build/Dcm/Linux/$MACHINE_TYPE"
            rm -rf ../build/Dcm/Linux/$MACHINE_TYPE
        elif [ "confdlatest" == "$i" ]; then
            echo "rmdir in $VOB_HOME/$SRC_PATH/$MACHINE_TYPE"
            rm -rf ./$MACHINE_TYPE
            echo "rm $VOB_HOME/$SRC_PATH/confd-$MACHINE_TYPE.tgz.extraction_completed"
            rm -f confd-$MACHINE_TYPE.tgz.extraction_completed
            cdsrc confd; cd LATEST
            echo "rm $VOB_HOME/$SRC_PATH/LATEST/confd-$MACHINE_TYPE.tgz.extraction_completed"
            rm -f confd-$MACHINE_TYPE.tgz.extraction_completed
        fi
    done

    echo "ORIGINAL DIR: $ORIGINAL_DIR"
    cd "$ORIGINAL_DIR"

    echo -e "[Completed Cleaning \"$CLEAN_TYPE\" $MACHINE_TYPE Wave/Dcm Source Areas.]"
}

function get_intel_os_type()
{
    local OS_TYPE=`getconf LONG_BIT`

    if [ 32 -eq $OS_TYPE ]; then
        echo "i686"
    else
        echo "x86_64"
    fi
}

function build_dcmd_stats()
{
    local EMAIL_ADDR="$USER@$DOMAIN_NAME"
    local CURRENT_VIEW=`get_current_view`
    local BUILD_TIME_STAMP=`get_build_time_stamp`
    local BUILD_STRING="$CURRENT_VIEW"__$BUILD_TIME_STAMP
    local LOG_FILE="/tmp/.$BUILD_STRING"
    local LOG_FILE2="/tmp/.$BUILD_STRING"_2

    echo "Build Log:" > $LOG_FILE
    echo "=========" >> $LOG_FILE

    (time build_dcmd "$@") 2>&1 | tee -a $LOG_FILE
    date | tee -a $LOG_FILE

    echo "Build Summary:" > $LOG_FILE2
    echo "=============" >> $LOG_FILE2
    tail -n 6 $LOG_FILE >> $LOG_FILE2
    echo -e "\n" >> $LOG_FILE2
    cat $LOG_FILE >> $LOG_FILE2

    rm -rf $LOG_FILE

    mail -s "$BUILD_STRING (x86) Build Completed" $EMAIL_ADDR < $LOG_FILE2

    rm -rf $LOG_FILE2
}

function build_dcmd()
{
    # save PWD
    local ORIGINAL_DIR=`pwd`
    local PATHS=""
    local NUM_GMAKE_JOBS="$NUM_CPU_CORES"
    local EMAKE_WRAPPER="emake_wrapper"

    if [[ $# -lt 1 || $# -gt 5 ]]; then
        echo "Usage: build_dcmd <build type - wave|waveapp|dcm|dcmapp|testapp|all> [clean] [OPTIMIZED=<0|1>] [SUB_DIRS=<sub dirs path appropriate for specified build type>] [GPROF=<0|1>] [PROFILE=<0|1>] [USE_STATIC_LIBS=<0|1> | USE_FULL_STATIC_LIBS=<0|1>] [SVIEW=<Static view name>]"
        return 1
    fi
    
    local BUILD_TYPE="$1"
    local CLEAN_FLAG_SET="false"
    local OPTIMIZED_OPTION=""
    local SUBDIRS_OPTION=""
    local GPROF_OPTION=""
    local PROFILE_OPTION=""
    local USE_STATIC_LIBS_OPTION=""
    local USE_FULL_STATIC_LIBS_OPTION=""
    local STATIC_VIEW_NAME=""
    local STATIC_VIEW_PATH_PREFIX=`get_view_path "$STATIC_VIEW_NAME"`
    local VOB_HOME=""
    local SRC_PATH=""

    if [ -n "$STATIC_VIEW_PATH_PREFIX" ]; then
        VOB_HOME="$STATIC_VIEW_PATH_PREFIX"
    else
        VOB_HOME=""
    fi

    for i in "$@"; do
        if [[ "$i" == "clean" ]]; then
            CLEAN_FLAG_SET="true"
        elif [[ "$i" =~ ^OPTIMIZED=[01] ]]; then
            OPTIMIZED_OPTION="$i"
        elif [[ "$i" =~ ^GPROF=[01] ]]; then
            GPROF_OPTION="$i"
        elif [[ "$i" =~ ^PROFILE=[01] ]]; then
            PROFILE_OPTION="$i"
        elif [[ "$i" =~ ^USE_STATIC_LIBS=[01] ]]; then
            USE_STATIC_LIBS_OPTION="$i"
        elif [[ "$i" =~ ^USE_FULL_STATIC_LIBS=[01] ]]; then
            USE_FULL_STATIC_LIBS_OPTION="$i"
        elif [[ "$i" =~ ^SUB_DIRS= ]]; then
            local SUBDIRS_PATH=${i#*=}

            if [[ "$SUBDIRS_PATH" =~ [[:space:]]+ ]]; then
                SUBDIRS_OPTION="SUB_DIRS=\"$SUBDIRS_PATH\""
            else
                SUBDIRS_OPTION="SUB_DIRS=$SUBDIRS_PATH"
            fi
        elif [[ "$i" =~ ^SVIEW= ]]; then
            STATIC_VIEW_NAME=${i#*=}
        fi
    done
        
    if [ -z "$BUILD_TYPE" ]; then
        echo "No build type specified!  Choose any combination of [wave waveapp dcm dcmapp testapp] or [all]"
        return 1
    elif [ "all" == "$BUILD_TYPE" ]; then
        PATHS=( make dcm dcmapp testapp datatypes )
    else
        PATHS="$BUILD_TYPE"
    fi

    if [ "$CLEAN_FLAG_SET" == "true" ]; then
        clean_dcmd "$BUILD_TYPE"
    fi

    for i in ${PATHS[@]}; do
        local SRC_PATH=`get_src_path "$i"`

        cd "$VOB_HOME/$SRC_PATH"

        if [ "$i" == "make" ]; then
            # Extract OSS binaries
            echo "[Extracting OSS binaries ...]"
            gmake -j $NUM_GMAKE_JOBS extract_oss_binaries
        elif [[ "$i" == "dcmapp" || "$i" == "testapp" || "$i" == "datatypes" ]]; then

            if [[ "$i" == "datatypes" ]]; then
                # Workaround for different GCC version error when partially building using electric cloud and xen.
                # electric cloud build server and xen have different gcc versions and confd cannot start due to a
                # version check with the confd datatypes shared library.
                echo "[Clean Confd Datatypes and Rebuild Workaround!]"
                gmake -j $NUM_GMAKE_JOBS clean
            fi

            echo "[Gmake $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION in $VOB_HOME/$SRC_PATH]"
            gmake -j $NUM_GMAKE_JOBS $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION
        else 
            echo "[Emake_wrapper $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION in $VOB_HOME/$SRC_PATH]"
            $EMAKE_WRAPPER $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION
        fi
        
        # Check return code for emake_wrapper
        local BUILD_EXIT_CODE=$?

        if [[ 0 -ne $BUILD_EXIT_CODE ]]; then
            echo "[Make FAILED for ($i) \"$VOB_HOME/$SRC_PATH\". Exit Code: $BUILD_EXIT_CODE]"
            return 2
        else
            echo "[Make completed for ($i) \"$VOB_HOME/$SRC_PATH\".]"
        fi
    done

    cd "$ORIGINAL_DIR"

    echo -e "\n[Build process completed SUCCESSFULLY.]"

    return 0
}

function build_dcmd_parallel_stats()
{
    local EMAIL_ADDR="$USER@$DOMAIN_NAME"
    local CURRENT_VIEW=`get_current_view`
    local BUILD_TIME_STAMP=`get_build_time_stamp`
    local BUILD_STRING="$CURRENT_VIEW"__$BUILD_TIME_STAMP
    local LOG_FILE="/tmp/.$BUILD_STRING"
    local LOG_FILE2="/tmp/.$BUILD_STRING"_2

    echo "Build Log:" > $LOG_FILE
    echo "=========" >> $LOG_FILE

    (time build_dcmd_parallel "$@") 2>&1 | tee -a $LOG_FILE
    date | tee -a $LOG_FILE

    echo "Build Summary:" > $LOG_FILE2
    echo "=============" >> $LOG_FILE2
    tail -n 6 $LOG_FILE >> $LOG_FILE2
    echo -e "\n" >> $LOG_FILE2
    cat $LOG_FILE >> $LOG_FILE2

    rm -rf $LOG_FILE

    mail -s "$BUILD_STRING (x86) Build Completed" $EMAIL_ADDR < $LOG_FILE2

    rm -rf $LOG_FILE2
}

function build_dcmd_parallel()
{
    local ORIGINAL_DIR=`pwd`
    local PATHS=""
    local NUM_GMAKE_JOBS="$NUM_CPU_CORES"
    local WAVE_BUILD_PID=""
    local SLEEP_TIME_BETWEEN_WAVE_AND_DCM=30
    #local TEMP_WAVE_BUILD_DIR="/tmp/`get_current_view`/wavebuild"
    #local TEMP_DCM_BUILD_DIR="/tmp/`get_current_view`/dcmbuild"

    if [[ $# -lt 1 || $# -gt 5 ]]; then
        echo "Usage: build_dcmd_parallel <build type - wave|waveapp|dcm|dcmapp|testapp|all> [clean] [OPTIMIZED=<0|1>] [SUB_DIRS=<sub dirs path appropriate for specified build type>] [GPROF=<0|1>] [PROFILE=<0|1>] [USE_STATIC_LIBS=<0|1> | USE_FULL_STATIC_LIBS=<0|1>] [SVIEW=<Static view name>]"
        return 1
    fi

    local BUILD_TYPE="$1"
    local CLEAN_FLAG_SET="false"
    local OPTIMIZED_OPTION=""
    local SUBDIRS_OPTION=""
    local GPROF_OPTION="" 
    local PROFILE_OPTION=""
    local USE_STATIC_LIBS_OPTION=""
    local USE_FULL_STATIC_LIBS_OPTION=""
    local STATIC_VIEW_NAME=""
    local STATIC_VIEW_PATH_PREFIX=`get_view_path "$STATIC_VIEW_NAME"`
    local VOB_HOME=""
    local SRC_PATH=""
    local WAVE_BUILD_PATH=""

    if [ -n "$STATIC_VIEW_PATH_PREFIX" ]; then
        VOB_HOME="$STATIC_VIEW_PATH_PREFIX"
    else
        VOB_HOME=""
    fi

    for i in "$@"; do
        if [[ "$i" == "clean" ]]; then
            CLEAN_FLAG_SET="true"
        elif [[ "$i" =~ ^OPTIMIZED=[01] ]]; then
            OPTIMIZED_OPTION="$i"
        elif [[ "$i" =~ ^GPROF=[01] ]]; then
            GPROF_OPTION="$i"
        elif [[ "$i" =~ ^PROFILE=[01] ]]; then
            PROFILE_OPTION="$i"
        elif [[ "$i" =~ ^USE_STATIC_LIBS=[01] ]]; then
            USE_STATIC_LIBS_OPTION="$i"
        elif [[ "$i" =~ ^USE_FULL_STATIC_LIBS=[01] ]]; then
            USE_FULL_STATIC_LIBS_OPTION="$i"
        elif [[ "$i" =~ ^SUB_DIRS= ]]; then
            local SUBDIRS_PATH=${i#*=}
            SUBDIRS_OPTION="SUB_DIRS=\"$SUBDIRS_PATH\""
        fi
    done

    if [ -z "$BUILD_TYPE" ]; then
        echo "No build type specified!  Choose any combination of [wave waveapp dcm dcmapp testapp] or [all]"
        return 1
    elif [ "all" == "$BUILD_TYPE" ]; then
        PATHS=( make wave waveapp dcm dcmapp testapp )
    else
        PATHS="$BUILD_TYPE"
    fi

    if [ "$CLEAN_FLAG_SET" == "true" ]; then
        clean_dcmd "$BUILD_TYPE"
    fi

    # Ensure tmpfs build directories are created

    #if [ ! -d "$TEMP_WAVE_BUILD_DIR" ]; then
    #    mkdir -p $TEMP_WAVE_BUILD_DIR
    #fi

    #if [ ! -d "$TEMP_DCM_BUILD_DIR" ]; then
    #    mkdir -p $TEMP_DCM_BUILD_DIR
    #fi

    for i in ${PATHS[@]}; do
        local SRC_PATH=`get_src_path "$i"`

        cd "$VOB_HOME/$SRC_PATH"
        
        if [ "$i" == "make" ]; then
            # Extract OSS binaries
            echo "[Extracting OSS binaries ...]"
            gmake -j $NUM_GMAKE_JOBS extract_oss_binaries
        elif [ "wave" == "$i" ]; then
            WAVE_BUILD_PATH="$VOB_HOME/$SRC_PATH"
            #ln -sf $TEMP_WAVE_BUILD_DIR ../build/Wave
            echo "[Gmake parallel jobs ($NUM_GMAKE_JOBS) $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION in $VOB_HOME/$SRC_PATH ...]"
            gmake -j $NUM_GMAKE_JOBS $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION &
            WAVE_BUILD_PID=$!
        elif [ "dcm" == "$i" ]; then
            #ln -sf $TEMP_DCM_BUILD_DIR ../build/Dcm
            echo "[Gmake parallel jobs ($NUM_GMAKE_JOBS) $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION in $VOB_HOME/$SRC_PATH ...]"
            gmake -j $NUM_GMAKE_JOBS $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION
        else
            echo "[Gmake parallel jobs ($NUM_GMAKE_JOBS) $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION in $VOB_HOME/$SRC_PATH ...]"
            gmake -j $NUM_GMAKE_JOBS $SUBDIRS_OPTION $OPTIMIZED_OPTION $GPROF_OPTION $PROFILE_OPTION $USE_STATIC_LIBS_OPTION $USE_FULL_STATIC_LIBS_OPTION
        fi

        local BUILD_EXIT_CODE=$?

        if [[ "wave" == "$i" ]]; then
            if [[ "$CLEAN_FLAG_SET" == "true" ]]; then
                # For clean builds, ensure wave resources are generated before launching dcm compliation.  Dcm Resourced has a dependency on wave Resources.
                echo "[Waiting \"$SLEEP_TIME_BETWEEN_WAVE_AND_DCM\" seconds for dynamic wave resource compilation ...]"
                sleep $SLEEP_TIME_BETWEEN_WAVE_AND_DCM
            fi
        else
            # Check return code for non-wave gmake
            if [[ 0 -ne $BUILD_EXIT_CODE ]]; then
                echo "[Gmake FAILED for ($i) \"$VOB_HOME/$SRC_PATH\". Exit Code: $BUILD_EXIT_CODE]"
                return $BUILD_EXIT_CODE 
            else
                echo "[Gmake completed for ($i) \"$VOB_HOME/$SRC_PATH\".]"
            fi
        fi
    done

    cd "$ORIGINAL_DIR"

    wait $WAVE_BUILD_PID
    local WAVE_BUILD_EXIT_CODE=$?
    
    # Check return code for wave gmake
    if [[ "wave" == `echo $PATHS | grep wave` ]]; then
        if [[ 0 -ne $WAVE_BUILD_EXIT_CODE ]]; then
            echo "[Gmake FAILED for (wave) \"$WAVE_BUILD_PATH\". Exit Code: $WAVE_BUILD_EXIT_CODE]"
            return $WAVE_BUILD_EXIT_CODE
        else
            echo "[Gmake completed for (wave) \"$WAVE_BUILD_PATH\".]"
        fi
    fi
    
    echo -e "\n[Build process completed SUCCESSFULLY.]"
    return 0
}

function build_dcmd_swbd()
{
    local USAGE="Usage: build_dcmd_swbd [BD Number(s) - 97|\"97 1000 1004\"] <build release string prefix> <build type - all|wave|dcm|dcmapp|yang|cli|dist|distclean|incr_build|emake> [clean_dist|clean_simulator] [DIST_DIR=<distribution directory path>] [SUB_DIRS=<sub dirs path appropriate for specified build type>]"

    if [[ $# -lt 1 || $# -gt 6 ]]; then
        echo "$USAGE"
        return 1
    fi

    local BUILD_PLATFORM=""
    local BUILD_RELEASE_PREFIX=""
    local BUILD_TYPE=""
    local DIST_DIR=""
    local SUBDIRS_OPTION=""
    local CLEAN_OPTION=""

    for i in "$@"; do
        if [[ "$i" =~ ^[0-9\ ]+$ ]]; then
            BUILD_PLATFORM="$i"
        elif [[ "$i" =~ (^clean_dist$|^clean_simulator$) ]]; then
            CLEAN_OPTION="$i"
        elif [[ "$i" =~ (^all$|^wave$|^dcm$|^dcmapp$|^yang$|^cli$|^dist$|^distclean$|^incr_build$|^emake$) ]]; then
            BUILD_TYPE="$i"
        elif [[ "$i" =~ ^[a-zA-Z0-9_.]+$ ]]; then
            BUILD_RELEASE_PREFIX="$i"
        elif [[ "$i" =~ ^SUB_DIRS= ]]; then
            SUBDIRS_OPTION="$i"
        elif [[ "$i" =~ ^DIST_DIR= ]]; then
            DIST_DIR="$i"
        else
            echo "$USAGE"
            echo "Unrecognized option \"$i\"."
        fi
    done

    if [ -z "$BUILD_RELEASE_PREFIX" ]; then
        echo "No build release string prefix specified!"
        return 1
    fi

    if [ -z "$BUILD_TYPE" ]; then
        echo "No build type specified!"
        return 2
    fi

    if [[ "$DIST_DIR" == "none" ]]; then
        echo "Distribution will be contained in the vob under $BASE_SRC/build/dist."
        DIST_DIR=" "
    elif [[ -z "$DIST_DIR" ]]; then 
        if [[ -d /bldimg/fusion/$USER/dist ]]; then
            DIST_DIR=/bldimg/fusion/$USER/dist 
        else
            DIST_DIR="$HOME/dist"

            if [ ! -d "$DIST_DIR" ]; then
                echo "Creating a distribution directory at $DIST_DIR"
                mkdir -p $DIST_DIR
            fi
        fi
    else
        if [ ! -d "$DIST_DIR" ]; then
            echo "Creating a distribution directory at $DIST_DIR"
            mkdir -p $DIST_DIR
        fi
    fi

    local EMAIL_ADDR="$USER@$DOMAIN_NAME"
    local CURRENT_VIEW=`get_current_view`
    local BUILD_TIME_STAMP=`get_build_time_stamp`
    local BUILD_STRING="$CURRENT_VIEW"__$BUILD_TIME_STAMP
    local LOG_FILE="/tmp/.$BUILD_STRING"
    local LOG_FILE2="/tmp/.$BUILD_STRING"_2

    echo "Build Log:" > $LOG_FILE
    echo "=========" >> $LOG_FILE

    (time build_dcmd_ppc "$BUILD_PLATFORM" $BUILD_RELEASE_PREFIX $BUILD_TYPE "$CLEAN_OPTION" $DIST_DIR "$SUBDIRS_OPTION") 2>&1 | tee -a $LOG_FILE
    date | tee -a $LOG_FILE

    echo "Build Summary:" > $LOG_FILE2
    echo "=============" >> $LOG_FILE2
    tail -n 14 $LOG_FILE >> $LOG_FILE2
    echo -e "\n" >> $LOG_FILE2
    
    local LOG_FILE_NUM_LINES=`wc $LOG_FILE | awk '{print $1}'`

    if [ 1000 -lt $LOG_FILE_NUM_LINES ]; then
        head -n 500 $LOG_FILE >> $LOG_FILE2
        echo -e "\n\n<<<========== T R U N C A T E D ==========>>>\n\n" >> $LOG_FILE2
        tail -n 500 $LOG_FILE >> $LOG_FILE2
    else
        cat $LOG_FILE >> $LOG_FILE2
    fi

    rm -rf "$LOG_FILE"

    mail -s "$BUILD_STRING (SWBD$BUILD_PLATFORM) Build Completed" $EMAIL_ADDR < $LOG_FILE2

    rm -rf "$LOG_FILE2"
}

function build_dcmd_ppc()
{
    local ORIGINAL_DIR=`pwd`
    local BUILD_TYPE=$3
    local CLEAN_OPTION=$4
    local DIST_DIR=$5
    local DEBUG_OPTION="DEBUG_FLAG_G=-g"
    local SUBDIRS_OPTION=""
    local NUM_GMAKE_JOBS="$NUM_CPU_CORES"

    for i in "$@"; do
        if [[ "$i" =~ ^SUB_DIRS= ]]; then
            local SUBDIRS_PATH=${i#*=}

            if [[ "$SUBDIRS_PATH" =~ [[:space:]]+ ]]; then
                SUBDIRS_OPTION="SUB_DIRS=\"$SUBDIRS_PATH\""
            else
                SUBDIRS_OPTION="SUB_DIRS=$SUBDIRS_PATH"  
            fi
        fi
    done

    if [ -z "$2" ]; then
        echo "No build release string prefix specified!"
        return 1
    fi
    
    local BUILD_PLATFORM=$1
    local BUILD_RELEASE=$2
    local BRANCH_NAME=`get_branch_name`
    local BUILD_TIME_STAMP=`get_build_time_stamp`
    local BD_PARAMETER=""
    local EMAKE_WRAPPER="emake_wrapper"
    
    if [ -z "$BRANCH_NAME" ]; then
        echo "The branch name could not be determined.  Is a view set correctly?"
        exit 1
    fi

    if [ -z "$BUILD_TIME_STAMP" ]; then
        echo "The build time stamp could not be determined.  Is the config spec set correctly?"
        exit 1
    fi

    if [[ "$BUILD_PLATFORM" =~ ^[[:space:]]*$ ]]; then
        if [ "$BUILD_TYPE" != "distclean" ]; then
            # If build platform is empty then auto discover existing SWBDs.

            echo "[Discovering SWBDs in build directory...]"

            local BUILD_SWBDS=`get_current_build_swbds`

            BUILD_PLATFORM=`echo $BUILD_SWBDS | sed s/swbd//g`
        fi
    fi

    local BUILD_PLATFORMS=( $BUILD_PLATFORM )

    if [[ ${#BUILD_PLATFORMS[@]} -eq 0 ]]; then
        BD_PARAMETER=""
    elif [[ ${#BUILD_PLATFORMS[@]} -eq 1 ]]; then
        BD_PARAMETER="BD=$BUILD_PLATFORM"
    else
        BD_PARAMETER="BD=\"$BUILD_PLATFORM\""
    fi

    # Append the current working view's timestamp to the build release

    BUILD_RELEASE="$BUILD_RELEASE"_$BUILD_TIME_STAMP 
    
    echo "Branch name    : $BRANCH_NAME"
    echo "Build platform : $BUILD_PLATFORM"
    echo "Build release  : $BUILD_RELEASE"
    echo "Build type     : $BUILD_TYPE"

    if [[ -n "$CLEAN_OPTION" ]]; then
        echo "Clean option   : $CLEAN_OPTION"
    fi

    if [[ -n "$SUBDIRS_OPTION" ]]; then
        echo "Build option   : $SUBDIRS_OPTION"
    fi

    echo ""
    
    # Clean build directories if clean flags are given.

    if [[ "$CLEAN_OPTION" =~ "clean_s" ]]; then
        # clean up the simulator

        echo "[Cleaning dcmd simulator directories for a clean symlink PPC build ...]"

        clean_dcmd "wave" && clean_dcmd "dcm"
    fi

    if [[ "$CLEAN_OPTION" =~ "clean" ]]; then
        local BUILD_DIR=`get_src_path "build"`

        echo "[Cleaning /$BUILD_DIR/dist intermediate distribution directory for PPC build ...]"

        cdsrc make; $EMAKE_WRAPPER clean_dist_only
    fi 

    # Launch emake_wrapper based on the BUILD_TYPE

    if [ "$BUILD_TYPE" == "dist" ]; then
        echo "[Launching emake_wrapper $BUILD_TYPE for PPC build ...]"

        if [ -d $DIST_DIR/$BUILD_RELEASE ]; then
            echo "[Distribution directory already exists.  Cleaning it up prior to build ...]"
            rm -rf $DIST_DIR/$BUILD_RELEASE/*
        fi

        echo "cdsrc make; emake_wrapper dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE"
        cdsrc make && $EMAKE_WRAPPER dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE
    elif [ "$BUILD_TYPE" == "distclean" ]; then
        echo "[Ensure build directory is cleaned up ...]"

        cdsrc build && rm -rf * > /dev/null 2>&1

        echo "[Launching emake_wrapper $BUILD_TYPE for PPC build ...]"

        cdsrc make && $EMAKE_WRAPPER distclean

        echo "[Launching emake_wrapper for PPC build ...]"

        if [ -z "$DIST_DIR" ]; then
            echo "cdsrc make; emake_wrapper $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE"
            cdsrc make && $EMAKE_WRAPPER $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE
        else
            if [ -d $DIST_DIR/$BUILD_RELEASE ]; then
                echo "Distribution directory already exists.  Cleaning it up prior to build ..."
                rm -rf $DIST_DIR/$BUILD_RELEASE/*
            fi

            echo "cdsrc make && emake_wrapper $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE"
            cdsrc make && $EMAKE_WRAPPER $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE
        fi
    elif [[ "$BUILD_TYPE" == "all" || "$BUILD_TYPE" == "yang" || "$BUILD_TYPE" == "cli" || "$BUILD_TYPE" == "wave" || "$BUILD_TYPE" == "dcm" || "$BUILD_TYPE" == "dcmapp" ]]; then

        for BD_NUM in $BUILD_PLATFORM; do
            local SRC_PATH=`get_src_path "build"`
            local BUILD_EXIT_CODE=0

            if [ -d /$SRC_PATH/swbd$BD_NUM ]; then
                if [[ "$BUILD_TYPE" == "all" || "$BUILD_TYPE" == "yang" ]]; then
                    echo "[Making YANG in swbd$BD_NUM ...]"
                    cdsrc yang$BD_NUM; gmake clean; gmake -j $NUM_GMAKE_JOBS

                    BUILD_EXIT_CODE=$?

                    if [[ 0 -ne $BUILD_EXIT_CODE ]]; then
                        echo "[Gmake failed for yang source!]"
                        exit $BUILD_EXIT_CODE
                    fi
                fi

                if [[ "$BUILD_TYPE" == "all" || "$BUILD_TYPE" == "cli" ]]; then
                    echo "[Making CLI in swbd$BD_NUM ...]"
                    cdsrc cli$BD_NUM; gmake clean; gmake -j $NUM_GMAKE_JOBS

                    BUILD_EXIT_CODE=$?

                    if [[ 0 -ne $BUILD_EXIT_CODE ]]; then
                        echo "[Gmake failed for cli source!]"
                        exit $BUILD_EXIT_CODE
                    fi
                fi

                if [[ "$BUILD_TYPE" == "all" || "$BUILD_TYPE" == "wave" ]]; then
                    echo "[Making WAVE in swbd$BD_NUM ...]"
                    cdsrc wave$BD_NUM; $EMAKE_WRAPPER $DEBUG_OPTION $SUBDIRS_OPTION

                    BUILD_EXIT_CODE=$?

                    if [[ 0 -ne $BUILD_EXIT_CODE ]]; then
                        echo "[Emake_wrapper failed for wave source!]"
                        exit $BUILD_EXIT_CODE
                    fi
                fi

                if [[ "$BUILD_TYPE" == "all" || "$BUILD_TYPE" == "dcm" ]]; then
                    echo "[Making DCM in swbd$BD_NUM ...]"
                    cdsrc dcm$BD_NUM; $EMAKE_WRAPPER $DEBUG_OPTION $SUBDIRS_OPTION

                    BUILD_EXIT_CODE=$?

                    if [[ 0 -ne $BUILD_EXIT_CODE ]]; then
                        echo "[Emake_wrapper failed for dcm source!]"
                        exit $BUILD_EXIT_CODE
                    fi
                fi

                if [[ "$BUILD_TYPE" == "all" || "$BUILD_TYPE" == "dcmapp" ]]; then
                    echo "[Making DCMAPP in swbd$BD_NUM ...]"
                    cdsrc dcmapp$BD_NUM; $EMAKE_WRAPPER $DEBUG_OPTION $SUBDIRS_OPTION

                    BUILD_EXIT_CODE=$?

                    if [[ 0 -ne $BUILD_EXIT_CODE ]]; then
                        echo "[Emake_wrapper failed dcmapp source!]"
                        exit $BUILD_EXIT_CODE
                    fi
                fi
            else
                echo "Symlink directory swbd$BD_NUM does not exist!  Please do a clean build first."
                exit 1
            fi
        done
        
        echo "[Rebuilding PPC distribution ...]"
        
        if [ -z "$DIST_DIR" ]; then
            echo "cdsrc make; emake_wrapper dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE"
            cdsrc make; $EMAKE_WRAPPER dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE
        else
            if [[ -d $DIST_DIR/$BUILD_RELEASE && -n "$CLEAN_OPTION" ]]; then
                echo "[Distribution directory already exists.  Cleaning it up prior to rebuild.]"
                rm -rf $DIST_DIR/$BUILD_RELEASE/*
            fi

            if [[ -n "$CLEAN_OPTION" ]]; then
                echo "cdsrc make; emake_wrapper dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE"
                cdsrc make; $EMAKE_WRAPPER dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE
            else
                echo "cdsrc make; emake_wrapper dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE"
                cdsrc make; $EMAKE_WRAPPER dist $BD_PARAMETER FABOSRELEASEID=$BUILD_RELEASE
            fi
        fi
    elif [[ "incr_build" =~ "$BUILD_TYPE" ]]; then
        echo "[Launching emake_wrapper $BUILD_TYPE for PPC build ...]"

        if [ -z "$DIST_DIR" ]; then
            echo "cdsrc make; emake_wrapper --incr_build $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE"
            cdsrc make; $EMAKE_WRAPPER --incr_build $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE
        else
            if [[ -d $DIST_DIR/$BUILD_RELEASE && -n "$CLEAN_OPTION" ]]; then
                echo "[Distribution directory already exists.  Cleaning it up prior to rebuild.]"
                rm -rf $DIST_DIR/$BUILD_RELEASE/*
            fi

            if [[ -n "$CLEAN_OPTION" ]]; then
                echo "cdsrc make; emake_wrapper --incr_build $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE"
                cdsrc make; $EMAKE_WRAPPER --incr_build $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE
            else
                echo "cdsrc make; emake_wrapper --incr_build $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE"
                cdsrc make; $EMAKE_WRAPPER --incr_build $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE
            fi
        fi
    elif [[ "emake" =~ "$BUILD_TYPE" ]]; then

        echo "[Launching emake_wrapper for PPC build ...]"

        if [ -z "$DIST_DIR" ]; then
            echo "cdsrc make; emake_wrapper $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE"
            cdsrc make; $EMAKE_WRAPPER $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE
        else
            if [[ -d $DIST_DIR/$BUILD_RELEASE && -n "$CLEAN_OPTION" ]]; then
                echo "[Distribution directory already exists.  Cleaning it up prior to build ...]"
                rm -rf $DIST_DIR/$BUILD_RELEASE/*
            fi

            if [[ -n "$CLEAN_OPTION" ]]; then
                echo "cdsrc make; emake_wrapper $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE"
                cdsrc make; $EMAKE_WRAPPER $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE DISTDIR=$DIST_DIR/$BUILD_RELEASE
            else
                echo "cdsrc make; emake_wrapper $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE"
                cdsrc make; $EMAKE_WRAPPER $BD_PARAMETER $DEBUG_OPTION FABOSRELEASEID=$BUILD_RELEASE
            fi
        fi
    else
        echo "Incorrect build type specified!"
        exit 2
    fi

    cd "$ORIGINAL_DIR"

    return 0
}

function get_current_view()
{
    if [[ -f $CLEARTOOL ]]; then
        $CLEARTOOL pwv | grep "Set view" | awk -F ": " '{print $2}'
    else
	echo $USER
    fi
}

function get_branch_name ()
{
    local CURRENT_VIEW=`get_current_view`
    local BRANCH_NAME=`/usr/rational/local/bin/getcslocation -get_branch_id -view $CURRENT_VIEW`

    echo "$BRANCH_NAME"
}

function get_build_time_stamp()
{
    local TIME_STAMP_FORMAT=$1
    local BRANCH_NAME=`get_branch_name`

    # Find the branch name from the config spec
    local BUILD_TIME_STAMP=`$CLEARTOOL catcs | grep $BRANCH_NAME | grep \* | grep -v mkbranch | grep -v LATEST | sed 's/.*created_since(\([^)]*\).*/\1/' | head -n 1`

    if [ -z "$BUILD_TIME_STAMP" ]; then
        return 
    fi

    if [ "$TIME_STAMP_FORMAT" == "raw" ]; then
        echo "$BUILD_TIME_STAMP"
        return
    fi

    # Convert clearcase timestamp to build label appropriate timestamp
    BUILD_TIME_STAMP=`echo $BUILD_TIME_STAMP | sed 's/\./ /'`
    BUILD_TIME_STAMP=`date -d "$BUILD_TIME_STAMP" +%y%m%d_%H%M`

    echo "$BUILD_TIME_STAMP"
}

function cdsrc()
{
    local USAGE="Usage: cdsrc [ wave[BD#] | waveapp[BD#] | dcm[BD#] | dcmapp[BD#] | testapp | common_src[BD#] | fabos[BD#] | bccb[BD#] | cfos[BD#] | bfos[BD#] | make | build | dist[BD#] | confd[BD#] | yang[BD#] | cli[BD#] | postgres[BD#] | oss[BD#] ]"

    if [[ $# -lt 1 || "$1" =~ (^-h$|^--help$) ]]; then
        echo "$USAGE"
        return 1
    fi

    local PREFIX_PATH=${1%%/*}
    local SUFFIX_PATH=""

    if [[ $1 =~ / ]]; then
        SUFFIX_PATH=/${1#*/}
    fi

    local SRC_PATH=`get_src_path "$PREFIX_PATH"`
    local STATIC_VIEW_PATH_PREFIX=`get_view_path "$2"`
    local VOB_HOME=""

    if [ -z "$SRC_PATH" ]; then 
        echo -e "$USAGE\nInvalid path specified.\n"
        return 1
    fi

    if [ -n "$STATIC_VIEW_PATH_PREFIX" ]; then
        VOB_HOME="$STATIC_VIEW_PATH_PREFIX/"
    else
        VOB_HOME=""
    fi

    cd "$VOB_HOME$SRC_PATH$SUFFIX_PATH"
}

function get_src_path()
{
    local SOURCE="$1"
    local SOURCE_PREFIX="${1//[0-9]/}"
    local SOURCE_SWBD="${1//[A-Za-z_]/}"
    local SWBD=""
    local INTEL_ARCH=`get_intel_os_type`
    local POSTGRES_VERSION=`get_postgres_version`
    local SRC_PATH=""

    if [[ "$SOURCE" == "target26" ]]; then
        SOURCE_PREFIX="$SOURCE"
    else
        if [ -z "$SOURCE_SWBD" ]; then
            SWBD=""   
        else
            SWBD="/build/swbd$SOURCE_SWBD"
        fi
    fi

    case "$SOURCE_PREFIX" in
    "common_src")
        SRC_PATH="$BASE_SRC$SWBD/common_src"     
        ;;
    "fabos")
        SRC_PATH="$BASE_SRC$SWBD/fabos"     
        ;;
    "src")
        SRC_PATH="$BASE_SRC$SWBD/fabos/src"     
        ;;
    "bccb")
        SRC_PATH="$BASE_SRC$SWBD/fabos/bccb"     
        ;;
    "cfos")
        SRC_PATH="$BASE_SRC$SWBD/fabos/cfos"     
        ;;
    "bfos")
        SRC_PATH="$BASE_SRC$SWBD/fabos/bfos"     
        ;;
    "wave")
        SRC_PATH="$BASE_SRC$SWBD/fabos/bccb/dsf/Wave/source"
        ;;
    "dcm")
        SRC_PATH="$BASE_SRC$SWBD/fabos/src/vcs/dcm/source"     
        ;;
    "confd")
        SRC_PATH="$BASE_SRC$SWBD/tps/confd"     
        ;;
    "confdlatest")
        SRC_PATH="$BASE_SRC/build/target26/confd/LATEST"     
        ;;
    "yang")
        SRC_PATH="$BASE_SRC$SWBD/fabos/src/yang"
        ;;
    "cli")
        SRC_PATH="$BASE_SRC$SWBD/fabos/src/confd/cli"
        ;;
    "datatypes")
        SRC_PATH="$BASE_SRC$SWBD/fabos/src/confd/datatypes"
        ;;
    "dist")
        SRC_PATH="$BASE_SRC$SWBD/dist"     
        ;;
    "ubreeze")
        SRC_PATH="$BASE_SRC$SWBD/fabos/bccb/dsf/Wave/breeze/uBreeze/uBreeze"
        ;;
    "waveapp")
        SRC_PATH="$BASE_SRC$SWBD/fabos/bccb/dsf/Wave/application"
        ;;
    "dcmapp")
        SRC_PATH="$BASE_SRC$SWBD/fabos/src/vcs/dcm/application"
        ;;
    "testapp")
        SRC_PATH="$BASE_SRC/fabos/src/vcs/dcm/TestApp"     
        ;;
    "dynamicsource")
        if [ "$SWBD" == "" ]; then
            SRC_PATH="$BASE_SRC/fabos/src/vcs/dcm/build/Dcm/Linux/$INTEL_ARCH/debug/DynamicSource"     
        else
            SRC_PATH="$BASE_SRC$SWBD/fabos/src/vcs/dcm/build/Dcm/Linux/powerpc/optimized/DynamicSource"
        fi
        ;;
    "postgres")
        SRC_PATH="$BASE_SRC/build/target26/postgresql/$INTEL_ARCH/$POSTGRES_VERSION/bin"     
        ;;
    "postgreshercules")
        SRC_PATH="$BASE_SRC$SWBD/fabos/bccb/dsf/Wave/build/Wave/Linux/$INTEL_ARCH/debug/dependencies/postgresql/8.4.4/bin"     
        ;;
    "oss")
        SRC_PATH="$BASE_SRC$SWBD/oss"     
        ;;
    "tps")
        SRC_PATH="$BASE_SRC$SWBD/tps"     
        ;;
    "zebos")
        SRC_PATH="$BASE_SRC$SWBD/tps/ZebOS"
        ;;
    "build")
        SRC_PATH="$BASE_SRC/build"     
        ;;
    "target26")
        SRC_PATH="$BASE_SRC/build/target26"     
        ;;
    "make")
        SRC_PATH="$BASE_SRC/make"     
        ;;
    *)
        SRC_PATH=""
        ;;
    esac

    echo "$SRC_PATH"
}
